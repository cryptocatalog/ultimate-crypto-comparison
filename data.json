[{"tag":"Bouncy Castle  release-1.8.1 - http://bouncycastle.org/","descr":"Bouncy Castle is a collection of APIs used in cryptography. It includes APIs for both the Java and the C# programming languages. The APIs are supported by a registered Australian charitable organization: Legion of the Bouncy Castle Inc.","License":{"plain":"- MIT\n","childs":{"0":[[{"content":"MIT","plain":"MIT\n","plainChilds":"","childs":[]}]]}},"Description":{"plain":"The Bouncy Castle Crypto package is a C# implementation of cryptographic algorithms and protocols, it was developed by the Legion of the Bouncy Castle, a registered Australian Charity, with a little help! The Legion, and the latest goings on with this package, can be found at http://www.bouncycastle.org. In addition to providing basic cryptography algorithms, the package also provides support for CMS, TSP, X.509 certificate generation and a variety of other standards such as OpenPGP.","childs":{"0":["The Bouncy Castle Crypto package is a C# implementation of cryptographic algorithms and protocols, it was developed by the Legion of the Bouncy Castle, a registered Australian Charity, with a little help! The Legion, and the latest goings on with this package, can be found at http://www.bouncycastle.org. In addition to providing basic cryptography algorithms, the package also provides support for CMS, TSP, X.509 certificate generation and a variety of other standards such as OpenPGP."]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/bcgit/bc-csharp>\n    - Last repository change: 2018-04-08T16:17:23\n    - Last checked: 2018-04-11T20:49:21","childs":[]}]]}},"Archive":{"plain":"- https://github.com/bcgit/bc-csharp/archive/release-1.8.1.zip\n","childs":{"0":[[{"content":"https://github.com/bcgit/bc-csharp/archive/release-1.8.1.zip","plain":"https://github.com/bcgit/bc-csharp/archive/release-1.8.1.zip\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Release: 1.8.1\n","childs":{"0":[[{"content":"Release: 1.8.1","plain":"Release: 1.8.1\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C#\n","childs":{"0":[[{"content":"C#","plain":"C#\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"bouncycastle","childs":{"0":["bouncycastle"]}},"CVE Product":{"plain":"legion-of-the-bouncy-castle-java-crytography-api","childs":{"0":["legion-of-the-bouncy-castle-java-crytography-api"]}},"Development Languages":{"plain":"- C#\n","childs":{"0":[[{"content":"C#","plain":"C#","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"3-Way","plain":"3-Way","plainChilds":"","childs":[]},{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"DFC","plain":"DFC","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"IDEA NXT","plain":"IDEA NXT","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"MMB","plain":"MMB","plainChilds":"","childs":[]},{"content":"NDS","plain":"NDS","plainChilds":"","childs":[]},{"content":"NOEKEON","plain":"NOEKEON","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"RC2","plain":"RC2","plainChilds":"","childs":[]},{"content":"RC5","plain":"RC5","plainChilds":"","childs":[]},{"content":"RC6","plain":"RC6","plainChilds":"","childs":[]},{"content":"Serpent","plain":"Serpent","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"SM4","plain":"SM4","plainChilds":"","childs":[]},{"content":"Threefish","plain":"Threefish","plainChilds":"","childs":[]},{"content":"TEA","plain":"TEA","plainChilds":"","childs":[]},{"content":"3DES","plain":"3DES","plainChilds":"","childs":[]},{"content":"Twofish","plain":"Twofish","plainChilds":"","childs":[]},{"content":"UES","plain":"UES","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"eSTREAM","plain":"eSTREAM","plainChilds":"","childs":[]},{"content":"ISAAC","plain":"ISAAC","plainChilds":"","childs":[]},{"content":"LEX","plain":"LEX","plainChilds":"","childs":[]},{"content":"MAG","plain":"MAG","plainChilds":"","childs":[]},{"content":"Py","plain":"Py","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]},{"content":"ZUC","plain":"ZUC","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"FSB","plain":"FSB","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"MD6","plain":"MD6","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SipHash","plain":"SipHash","plainChilds":"","childs":[]},{"content":"Skein","plain":"Skein","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IGE","plain":"IGE","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"OCB","plain":"OCB","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"RAC","plain":"RAC","plainChilds":"","childs":[]},{"content":"RKC","plain":"RKC","plainChilds":"","childs":[]},{"content":"SIV","plain":"SIV","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"OMAC","plain":"OMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"LUC","plain":"LUC","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]},{"content":"YAK","plain":"YAK","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"LDAP","plain":"LDAP","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"PKIX","plain":"PKIX","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"AS1","plain":"AS1","plainChilds":"","childs":[]},{"content":"AKA","plain":"AKA","plainChilds":"","childs":[]},{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"CSR","plain":"CSR","plainChilds":"","childs":[]},{"content":"CMS","plain":"CMS","plainChilds":"","childs":[]},{"content":"DTLS","plain":"DTLS","plainChilds":"","childs":[]},{"content":"DPD","plain":"DPD","plainChilds":"","childs":[]},{"content":"DPV","plain":"DPV","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"GPG","plain":"GPG","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"I2P","plain":"I2P","plainChilds":"","childs":[]},{"content":"IES","plain":"IES","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"ISAKMP","plain":"ISAKMP","plainChilds":"","childs":[]},{"content":"IPsec","plain":"IPsec","plainChilds":"","childs":[]},{"content":"MSE","plain":"MSE","plainChilds":"","childs":[]},{"content":"OTR","plain":"OTR","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"PHE","plain":"PHE","plainChilds":"","childs":[]},{"content":"PGP","plain":"PGP","plainChilds":"","childs":[]},{"content":"RTD","plain":"RTD","plainChilds":"","childs":[]},{"content":"SCVP","plain":"SCVP","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SRTP","plain":"SRTP","plainChilds":"","childs":[]},{"content":"SSH","plain":"SSH","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]},{"content":"TSP","plain":"TSP","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"VBR","plain":"VBR","plainChilds":"","childs":[]},{"content":"WPA","plain":"WPA","plainChilds":"","childs":[]},{"content":"WPS","plain":"WPS","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed. (<https://cve.circl.lu/cve/CVE-2016-2427>)\n - The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n - The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes. (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","childs":{"0":[[{"content":"- ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed. (<https://cve.circl.lu/cve/CVE-2016-2427>)\n - The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n - The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes. (<https://cve.circl.lu/cve/CVE-2007-6721>)","plain":"- ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed. (<https://cve.circl.lu/cve/CVE-2016-2427>)\n - The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n - The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes. (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Bouncy Castle - http://bouncycastle.org/","descr":"Bouncy Castle C# Fips without repository and link to archive.","License":{"plain":"- MIT\n","childs":{"0":[[{"content":"MIT","plain":"MIT\n","plainChilds":"","childs":[]}]]}},"Description":{"plain":"The Bouncy Castle Crypto package is a C# implementation of cryptographic algorithms and protocols, it was developed by the Legion of the Bouncy Castle, a registered Australian Charity, with a little help! The Legion, and the latest goings on with this package, can be found at http://www.bouncycastle.org. In addition to providing basic cryptography algorithms, the package also provides support for CMS, TSP, X.509 certificate generation and a variety of other standards such as OpenPGP.","childs":{"0":["The Bouncy Castle Crypto package is a C# implementation of cryptographic algorithms and protocols, it was developed by the Legion of the Bouncy Castle, a registered Australian Charity, with a little help! The Legion, and the latest goings on with this package, can be found at http://www.bouncycastle.org. In addition to providing basic cryptography algorithms, the package also provides support for CMS, TSP, X.509 certificate generation and a variety of other standards such as OpenPGP."]}},"Repository":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C# FIPS\n","childs":{"0":[[{"content":"C# FIPS","plain":"C# FIPS\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"bouncycastle","childs":{"0":["bouncycastle"]}},"CVE Product":{"plain":"legion-of-the-bouncy-castle-java-crytography-api","childs":{"0":["legion-of-the-bouncy-castle-java-crytography-api"]}},"Development Languages":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed. (<https://cve.circl.lu/cve/CVE-2016-2427>)\n - The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n - The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes. (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","childs":{"0":[[{"content":"- ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed. (<https://cve.circl.lu/cve/CVE-2016-2427>)\n - The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n - The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes. (<https://cve.circl.lu/cve/CVE-2007-6721>)","plain":"- ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed. (<https://cve.circl.lu/cve/CVE-2016-2427>)\n - The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n - The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes. (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Botan - https://botan.randombit.net/","descr":"Botan is a BSD-licensed cryptographic library written in C++. It provides a wide variety of cryptographic algorithms, formats, and protocols, e.g. SSL and TLS. It is used in the Monotone distributed revision control program, the OpenDNSSEC system, and ISC's Kea DHCP server among other projects.","License":{"plain":"- BSD-2-Clause\n","childs":{"0":[[{"content":"BSD-2-Clause","plain":"BSD-2-Clause\n","plainChilds":"","childs":[]}]]}},"Description":{"plain":"Botan's goal is to be the best option for cryptography in new C++ code by offering the tools necessary to implement a range of practical systems, such as TLS/DTLS, PKIX certificate handling, PKCS#11 and TPM hardware support, password hashing, and post quantum crypto schemes. In addition to the C++, botan has a C89 API specifically designed to be easy to call from other languages. A Python binding using ctypes is included, and several other language bindings are available.","childs":{"0":["Botan's goal is to be the best option for cryptography in new C++ code by offering the tools necessary to implement a range of practical systems, such as TLS/DTLS, PKIX certificate handling, PKCS#11 and TPM hardware support, password hashing, and post quantum crypto schemes. In addition to the C++, botan has a C89 API specifically designed to be easy to call from other languages. A Python binding using ctypes is included, and several other language bindings are available."]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/randombit/botan>\n    - Last repository change: 2018-04-11T14:04:04\n    - Last checked: 2018-04-11T20:49:21","childs":[]}]]}},"Interface Languages":{"plain":"- C++11\n","childs":{"0":[[{"content":"C++11","plain":"C++11\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"botan_project","childs":{"0":["botan_project"]}},"CVE Product":{"plain":"botan","childs":{"0":["botan"]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 797\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 797","plain":"Stars: 797","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C++\n- Python\n","childs":{"0":[[{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"Python","plain":"Python","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"ARIA","plain":"ARIA","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"CAST-128","plain":"CAST-128","plainChilds":"","childs":[]},{"content":"CAST-256","plain":"CAST-256","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"FPE","plain":"FPE","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"IDEA NXT","plain":"IDEA NXT","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"KASUMI","plain":"KASUMI","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"Mercy","plain":"Mercy","plainChilds":"","childs":[]},{"content":"MISTY1","plain":"MISTY1","plainChilds":"","childs":[]},{"content":"MMB","plain":"MMB","plainChilds":"","childs":[]},{"content":"NDS","plain":"NDS","plainChilds":"","childs":[]},{"content":"NOEKEON","plain":"NOEKEON","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"RC2","plain":"RC2","plainChilds":"","childs":[]},{"content":"RC5","plain":"RC5","plainChilds":"","childs":[]},{"content":"SAFER","plain":"SAFER","plainChilds":"","childs":[]},{"content":"Serpent","plain":"Serpent","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"SHACAL","plain":"SHACAL","plainChilds":"","childs":[]},{"content":"Simon","plain":"Simon","plainChilds":"","childs":[]},{"content":"SM4","plain":"SM4","plainChilds":"","childs":[]},{"content":"Threefish","plain":"Threefish","plainChilds":"","childs":[]},{"content":"TEA","plain":"TEA","plainChilds":"","childs":[]},{"content":"Twofish","plain":"Twofish","plainChilds":"","childs":[]},{"content":"XTEA","plain":"XTEA","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"Dragon","plain":"Dragon","plainChilds":"","childs":[]},{"content":"eSTREAM","plain":"eSTREAM","plainChilds":"","childs":[]},{"content":"LEX","plain":"LEX","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]},{"content":"Turing","plain":"Turing","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"MD6","plain":"MD6","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SipHash","plain":"SipHash","plainChilds":"","childs":[]},{"content":"Skein","plain":"Skein","plainChilds":"","childs":[]},{"content":"Streebog","plain":"Streebog","plainChilds":"","childs":[]},{"content":"Tiger","plain":"Tiger","plainChilds":"","childs":[]},{"content":"WHIRLPOOL","plain":"WHIRLPOOL","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"BPS","plain":"BPS","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"OCB","plain":"OCB","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"RAC","plain":"RAC","plainChilds":"","childs":[]},{"content":"SIV","plain":"SIV","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"ElGamal","plain":"ElGamal","plainChilds":"","childs":[]},{"content":"McEliece","plain":"McEliece","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"Identrus","plain":"Identrus","plainChilds":"","childs":[]},{"content":"LDAP","plain":"LDAP","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"PKIX","plain":"PKIX","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"AS2","plain":"AS2","plainChilds":"","childs":[]},{"content":"AKA","plain":"AKA","plainChilds":"","childs":[]},{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"CSR","plain":"CSR","plainChilds":"","childs":[]},{"content":"CMS","plain":"CMS","plainChilds":"","childs":[]},{"content":"DTLS","plain":"DTLS","plainChilds":"","childs":[]},{"content":"DPD","plain":"DPD","plainChilds":"","childs":[]},{"content":"DPV","plain":"DPV","plainChilds":"","childs":[]},{"content":"DCII","plain":"DCII","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"GPG","plain":"GPG","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"MSE","plain":"MSE","plainChilds":"","childs":[]},{"content":"OTR","plain":"OTR","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PCT","plain":"PCT","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"PHE","plain":"PHE","plainChilds":"","childs":[]},{"content":"PGP","plain":"PGP","plainChilds":"","childs":[]},{"content":"RTD","plain":"RTD","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SRTP","plain":"SRTP","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- A cryptographic cache-based side channel in the RSA implementation in Botan before 1.10.17, and 1.11.x and 2.x before 2.3.0, allows a local attacker to recover information about RSA secret keys, as demonstrated by CacheD. This occurs because an array is indexed with bits derived from a secret key. (<https://cve.circl.lu/cve/CVE-2017-14737>)\n - A programming error exists in a way Randombit Botan cryptographic library version 2.0.1 implements x500 string comparisons which could lead to certificate verification issues and abuse. A specially crafted X509 certificate would need to be delivered to the client or server application in order to trigger this vulnerability. (<https://cve.circl.lu/cve/CVE-2017-2801>)\n - The X509_Certificate::allowed_usage function in botan 1.11.x before 1.11.31 might allow attackers to have unspecified impact by leveraging a call with more than one Key_Usage set in the enum value. (<https://cve.circl.lu/cve/CVE-2016-6879>)\n - The Curve25519 code in botan before 1.11.31, on systems without a native 128-bit integer type, might allow attackers to have unspecified impact via vectors related to undefined behavior, as demonstrated on 32-bit ARM systems compiled by Clang. (<https://cve.circl.lu/cve/CVE-2016-6878>)\n - botan 1.11.x before 1.11.22 makes it easier for remote attackers to decrypt TLS ciphertext data via a padding-oracle attack against TLS CBC ciphersuites. (<https://cve.circl.lu/cve/CVE-2015-7824>)\n - botan before 1.11.22 improperly validates certificate paths, which allows remote attackers to cause a denial of service (infinite loop and memory consumption) via a certificate with a loop in the certificate chain. (<https://cve.circl.lu/cve/CVE-2015-7825>)\n - botan 1.11.x before 1.11.22 improperly handles wildcard matching against hostnames, which might allow remote attackers to have unspecified impact via a valid X.509 certificate, as demonstrated by accepting *.example.com as a match for bar.foo.example.com. (<https://cve.circl.lu/cve/CVE-2015-7826>)\n - In Botan 1.8.0 through 1.11.33, when decoding BER data an integer overflow could occur, which would cause an incorrect length field to be computed. Some API callers may use the returned (incorrect and attacker controlled) length field in a way which later causes memory corruption or other failure. (<https://cve.circl.lu/cve/CVE-2016-9132>)\n - In Botan 1.11.29 through 1.11.32, RSA decryption with certain padding options had a detectable timing channel which could given sufficient queries be used to recover plaintext, aka an OAEP side channel attack. (<https://cve.circl.lu/cve/CVE-2016-8871>)\n - Botan before 1.10.13 and 1.11.x before 1.11.22 make it easier for remote attackers to conduct million-message attacks by measuring time differences, related to decoding of PKCS#1 padding. (<https://cve.circl.lu/cve/CVE-2015-7827>)\n - Botan before 1.10.13 and 1.11.x before 1.11.29 do not use a constant-time algorithm to perform a modular inverse on the signature nonce k, which might allow remote attackers to obtain ECDSA secret keys via a timing side-channel attack. (<https://cve.circl.lu/cve/CVE-2016-2849>)\n - Botan 1.11.x before 1.11.29 does not enforce TLS policy for (1) signature algorithms and (2) ECC curves, which allows remote attackers to conduct downgrade attacks via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2850>)\n - The ressol function in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (infinite loop) via unspecified input to the OS2ECP function, related to a composite modulus. (<https://cve.circl.lu/cve/CVE-2016-2194>)\n - Integer overflow in the PointGFp constructor in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to overwrite memory and possibly execute arbitrary code via a crafted ECC point, which triggers a heap-based buffer overflow. (<https://cve.circl.lu/cve/CVE-2016-2195>)\n - Heap-based buffer overflow in the P-521 reduction function in Botan 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (memory overwrite and crash) or execute arbitrary code via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2196>)\n - The BER decoder in Botan 0.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (application crash) via an empty BIT STRING in ASN.1 data. (<https://cve.circl.lu/cve/CVE-2015-5726>)\n - The Miller-Rabin primality check in Botan before 1.10.8 and 1.11.x before 1.11.9 improperly uses a single random base, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via a DH group. (<https://cve.circl.lu/cve/CVE-2014-9742>)\n - The BER decoder in Botan 1.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (memory consumption) via unspecified vectors, related to a length field. (<https://cve.circl.lu/cve/CVE-2015-5727>)\u0000","childs":{"0":[[{"content":"- A cryptographic cache-based side channel in the RSA implementation in Botan before 1.10.17, and 1.11.x and 2.x before 2.3.0, allows a local attacker to recover information about RSA secret keys, as demonstrated by CacheD. This occurs because an array is indexed with bits derived from a secret key. (<https://cve.circl.lu/cve/CVE-2017-14737>)\n - A programming error exists in a way Randombit Botan cryptographic library version 2.0.1 implements x500 string comparisons which could lead to certificate verification issues and abuse. A specially crafted X509 certificate would need to be delivered to the client or server application in order to trigger this vulnerability. (<https://cve.circl.lu/cve/CVE-2017-2801>)\n - The X509_Certificate::allowed_usage function in botan 1.11.x before 1.11.31 might allow attackers to have unspecified impact by leveraging a call with more than one Key_Usage set in the enum value. (<https://cve.circl.lu/cve/CVE-2016-6879>)\n - The Curve25519 code in botan before 1.11.31, on systems without a native 128-bit integer type, might allow attackers to have unspecified impact via vectors related to undefined behavior, as demonstrated on 32-bit ARM systems compiled by Clang. (<https://cve.circl.lu/cve/CVE-2016-6878>)\n - botan 1.11.x before 1.11.22 makes it easier for remote attackers to decrypt TLS ciphertext data via a padding-oracle attack against TLS CBC ciphersuites. (<https://cve.circl.lu/cve/CVE-2015-7824>)\n - botan before 1.11.22 improperly validates certificate paths, which allows remote attackers to cause a denial of service (infinite loop and memory consumption) via a certificate with a loop in the certificate chain. (<https://cve.circl.lu/cve/CVE-2015-7825>)\n - botan 1.11.x before 1.11.22 improperly handles wildcard matching against hostnames, which might allow remote attackers to have unspecified impact via a valid X.509 certificate, as demonstrated by accepting *.example.com as a match for bar.foo.example.com. (<https://cve.circl.lu/cve/CVE-2015-7826>)\n - In Botan 1.8.0 through 1.11.33, when decoding BER data an integer overflow could occur, which would cause an incorrect length field to be computed. Some API callers may use the returned (incorrect and attacker controlled) length field in a way which later causes memory corruption or other failure. (<https://cve.circl.lu/cve/CVE-2016-9132>)\n - In Botan 1.11.29 through 1.11.32, RSA decryption with certain padding options had a detectable timing channel which could given sufficient queries be used to recover plaintext, aka an OAEP side channel attack. (<https://cve.circl.lu/cve/CVE-2016-8871>)\n - Botan before 1.10.13 and 1.11.x before 1.11.22 make it easier for remote attackers to conduct million-message attacks by measuring time differences, related to decoding of PKCS#1 padding. (<https://cve.circl.lu/cve/CVE-2015-7827>)\n - Botan before 1.10.13 and 1.11.x before 1.11.29 do not use a constant-time algorithm to perform a modular inverse on the signature nonce k, which might allow remote attackers to obtain ECDSA secret keys via a timing side-channel attack. (<https://cve.circl.lu/cve/CVE-2016-2849>)\n - Botan 1.11.x before 1.11.29 does not enforce TLS policy for (1) signature algorithms and (2) ECC curves, which allows remote attackers to conduct downgrade attacks via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2850>)\n - The ressol function in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (infinite loop) via unspecified input to the OS2ECP function, related to a composite modulus. (<https://cve.circl.lu/cve/CVE-2016-2194>)\n - Integer overflow in the PointGFp constructor in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to overwrite memory and possibly execute arbitrary code via a crafted ECC point, which triggers a heap-based buffer overflow. (<https://cve.circl.lu/cve/CVE-2016-2195>)\n - Heap-based buffer overflow in the P-521 reduction function in Botan 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (memory overwrite and crash) or execute arbitrary code via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2196>)\n - The BER decoder in Botan 0.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (application crash) via an empty BIT STRING in ASN.1 data. (<https://cve.circl.lu/cve/CVE-2015-5726>)\n - The Miller-Rabin primality check in Botan before 1.10.8 and 1.11.x before 1.11.9 improperly uses a single random base, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via a DH group. (<https://cve.circl.lu/cve/CVE-2014-9742>)\n - The BER decoder in Botan 1.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (memory consumption) via unspecified vectors, related to a length field. (<https://cve.circl.lu/cve/CVE-2015-5727>)","plain":"- A cryptographic cache-based side channel in the RSA implementation in Botan before 1.10.17, and 1.11.x and 2.x before 2.3.0, allows a local attacker to recover information about RSA secret keys, as demonstrated by CacheD. This occurs because an array is indexed with bits derived from a secret key. (<https://cve.circl.lu/cve/CVE-2017-14737>)\n - A programming error exists in a way Randombit Botan cryptographic library version 2.0.1 implements x500 string comparisons which could lead to certificate verification issues and abuse. A specially crafted X509 certificate would need to be delivered to the client or server application in order to trigger this vulnerability. (<https://cve.circl.lu/cve/CVE-2017-2801>)\n - The X509_Certificate::allowed_usage function in botan 1.11.x before 1.11.31 might allow attackers to have unspecified impact by leveraging a call with more than one Key_Usage set in the enum value. (<https://cve.circl.lu/cve/CVE-2016-6879>)\n - The Curve25519 code in botan before 1.11.31, on systems without a native 128-bit integer type, might allow attackers to have unspecified impact via vectors related to undefined behavior, as demonstrated on 32-bit ARM systems compiled by Clang. (<https://cve.circl.lu/cve/CVE-2016-6878>)\n - botan 1.11.x before 1.11.22 makes it easier for remote attackers to decrypt TLS ciphertext data via a padding-oracle attack against TLS CBC ciphersuites. (<https://cve.circl.lu/cve/CVE-2015-7824>)\n - botan before 1.11.22 improperly validates certificate paths, which allows remote attackers to cause a denial of service (infinite loop and memory consumption) via a certificate with a loop in the certificate chain. (<https://cve.circl.lu/cve/CVE-2015-7825>)\n - botan 1.11.x before 1.11.22 improperly handles wildcard matching against hostnames, which might allow remote attackers to have unspecified impact via a valid X.509 certificate, as demonstrated by accepting *.example.com as a match for bar.foo.example.com. (<https://cve.circl.lu/cve/CVE-2015-7826>)\n - In Botan 1.8.0 through 1.11.33, when decoding BER data an integer overflow could occur, which would cause an incorrect length field to be computed. Some API callers may use the returned (incorrect and attacker controlled) length field in a way which later causes memory corruption or other failure. (<https://cve.circl.lu/cve/CVE-2016-9132>)\n - In Botan 1.11.29 through 1.11.32, RSA decryption with certain padding options had a detectable timing channel which could given sufficient queries be used to recover plaintext, aka an OAEP side channel attack. (<https://cve.circl.lu/cve/CVE-2016-8871>)\n - Botan before 1.10.13 and 1.11.x before 1.11.22 make it easier for remote attackers to conduct million-message attacks by measuring time differences, related to decoding of PKCS#1 padding. (<https://cve.circl.lu/cve/CVE-2015-7827>)\n - Botan before 1.10.13 and 1.11.x before 1.11.29 do not use a constant-time algorithm to perform a modular inverse on the signature nonce k, which might allow remote attackers to obtain ECDSA secret keys via a timing side-channel attack. (<https://cve.circl.lu/cve/CVE-2016-2849>)\n - Botan 1.11.x before 1.11.29 does not enforce TLS policy for (1) signature algorithms and (2) ECC curves, which allows remote attackers to conduct downgrade attacks via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2850>)\n - The ressol function in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (infinite loop) via unspecified input to the OS2ECP function, related to a composite modulus. (<https://cve.circl.lu/cve/CVE-2016-2194>)\n - Integer overflow in the PointGFp constructor in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to overwrite memory and possibly execute arbitrary code via a crafted ECC point, which triggers a heap-based buffer overflow. (<https://cve.circl.lu/cve/CVE-2016-2195>)\n - Heap-based buffer overflow in the P-521 reduction function in Botan 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (memory overwrite and crash) or execute arbitrary code via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2196>)\n - The BER decoder in Botan 0.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (application crash) via an empty BIT STRING in ASN.1 data. (<https://cve.circl.lu/cve/CVE-2015-5726>)\n - The Miller-Rabin primality check in Botan before 1.10.8 and 1.11.x before 1.11.9 improperly uses a single random base, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via a DH group. (<https://cve.circl.lu/cve/CVE-2014-9742>)\n - The BER decoder in Botan 1.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (memory consumption) via unspecified vectors, related to a length field. (<https://cve.circl.lu/cve/CVE-2015-5727>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Bouncy Castle  r1rv59 - http://bouncycastle.org/","descr":"Bouncy Castle is a collection of APIs used in cryptography. It includes APIs for both the Java and the C# programming languages. The APIs are supported by a registered Australian charitable organization: Legion of the Bouncy Castle Inc.","License":{"plain":"- MIT\n","childs":{"0":[[{"content":"MIT","plain":"MIT\n","plainChilds":"","childs":[]}]]}},"Description":{"plain":"The Bouncy Castle Crypto package is a C# implementation of cryptographic algorithms and protocols, it was developed by the Legion of the Bouncy Castle, a registered Australian Charity, with a little help! The Legion, and the latest goings on with this package, can be found at http://www.bouncycastle.org. In addition to providing basic cryptography algorithms, the package also provides support for CMS, TSP, X.509 certificate generation and a variety of other standards such as OpenPGP.","childs":{"0":["The Bouncy Castle Crypto package is a C# implementation of cryptographic algorithms and protocols, it was developed by the Legion of the Bouncy Castle, a registered Australian Charity, with a little help! The Legion, and the latest goings on with this package, can be found at http://www.bouncycastle.org. In addition to providing basic cryptography algorithms, the package also provides support for CMS, TSP, X.509 certificate generation and a variety of other standards such as OpenPGP."]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/bcgit/bc-java>\n    - Last repository change: 2018-04-05T01:19:45\n    - Last checked: 2018-04-11T20:49:21","childs":[]}]]}},"Archive":{"plain":"- https://github.com/bcgit/bc-java/archive/r1rv59.zip\n","childs":{"0":[[{"content":"https://github.com/bcgit/bc-java/archive/r1rv59.zip","plain":"https://github.com/bcgit/bc-java/archive/r1rv59.zip\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- Java\n","childs":{"0":[[{"content":"Java","plain":"Java\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Release: 1.59\n- Release Date: 2017-12-18\n","childs":{"0":[[{"content":"Release: 1.59","plain":"Release: 1.59\n","plainChilds":"","childs":[]},{"content":"Release Date: 2017-12-18","plain":"Release Date: 2017-12-18\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"bouncycastle","childs":{"0":["bouncycastle"]}},"CVE Product":{"plain":"legion-of-the-bouncy-castle-java-crytography-api","childs":{"0":["legion-of-the-bouncy-castle-java-crytography-api"]}},"Development Languages":{"plain":"- Java\n","childs":{"0":[[{"content":"Java","plain":"Java","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"3-Way","plain":"3-Way","plainChilds":"","childs":[]},{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"ARIA","plain":"ARIA","plainChilds":"","childs":[]},{"content":"ARIA-128","plain":"ARIA-128","plainChilds":"","childs":[]},{"content":"ARIA-192","plain":"ARIA-192","plainChilds":"","childs":[]},{"content":"ARIA-256","plain":"ARIA-256","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"DFC","plain":"DFC","plainChilds":"","childs":[]},{"content":"FPE","plain":"FPE","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"IDEA NXT","plain":"IDEA NXT","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"MMB","plain":"MMB","plainChilds":"","childs":[]},{"content":"NDS","plain":"NDS","plainChilds":"","childs":[]},{"content":"NOEKEON","plain":"NOEKEON","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"RC2","plain":"RC2","plainChilds":"","childs":[]},{"content":"RC5","plain":"RC5","plainChilds":"","childs":[]},{"content":"RC6","plain":"RC6","plainChilds":"","childs":[]},{"content":"SAFER","plain":"SAFER","plainChilds":"","childs":[]},{"content":"Serpent","plain":"Serpent","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"SM4","plain":"SM4","plainChilds":"","childs":[]},{"content":"Threefish","plain":"Threefish","plainChilds":"","childs":[]},{"content":"TEA","plain":"TEA","plainChilds":"","childs":[]},{"content":"3DES","plain":"3DES","plainChilds":"","childs":[]},{"content":"Twofish","plain":"Twofish","plainChilds":"","childs":[]},{"content":"UES","plain":"UES","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"Crypto1","plain":"Crypto1","plainChilds":"","childs":[]},{"content":"eSTREAM","plain":"eSTREAM","plainChilds":"","childs":[]},{"content":"FISH","plain":"FISH","plainChilds":"","childs":[]},{"content":"ISAAC","plain":"ISAAC","plainChilds":"","childs":[]},{"content":"LEX","plain":"LEX","plainChilds":"","childs":[]},{"content":"MAG","plain":"MAG","plainChilds":"","childs":[]},{"content":"NLS","plain":"NLS","plainChilds":"","childs":[]},{"content":"Py","plain":"Py","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]},{"content":"SEAL","plain":"SEAL","plainChilds":"","childs":[]},{"content":"Turing","plain":"Turing","plainChilds":"","childs":[]},{"content":"ZUC","plain":"ZUC","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"FSB","plain":"FSB","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"MD6","plain":"MD6","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SHAKE","plain":"SHAKE","plainChilds":"","childs":[]},{"content":"SipHash","plain":"SipHash","plainChilds":"","childs":[]},{"content":"Skein","plain":"Skein","plainChilds":"","childs":[]},{"content":"Streebog","plain":"Streebog","plainChilds":"","childs":[]},{"content":"WHIRLPOOL","plain":"WHIRLPOOL","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"BPS","plain":"BPS","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IGE","plain":"IGE","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"KFB","plain":"KFB","plainChilds":"","childs":[]},{"content":"OCB","plain":"OCB","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"RAC","plain":"RAC","plainChilds":"","childs":[]},{"content":"RKC","plain":"RKC","plainChilds":"","childs":[]},{"content":"SIV","plain":"SIV","plainChilds":"","childs":[]},{"content":"XBC","plain":"XBC","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"OMAC","plain":"OMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"ElGamal","plain":"ElGamal","plainChilds":"","childs":[]},{"content":"LUC","plain":"LUC","plainChilds":"","childs":[]},{"content":"McEliece","plain":"McEliece","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]},{"content":"YAK","plain":"YAK","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"DVCS","plain":"DVCS","plainChilds":"","childs":[]},{"content":"LDAP","plain":"LDAP","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"PKIX","plain":"PKIX","plainChilds":"","childs":[]},{"content":"PKCS#7","plain":"PKCS#7","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]},{"content":"XiPKI","plain":"XiPKI","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"AS1","plain":"AS1","plainChilds":"","childs":[]},{"content":"AS2","plain":"AS2","plainChilds":"","childs":[]},{"content":"AKA","plain":"AKA","plainChilds":"","childs":[]},{"content":"CMC","plain":"CMC","plainChilds":"","childs":[]},{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"CSR","plain":"CSR","plainChilds":"","childs":[]},{"content":"CMS","plain":"CMS","plainChilds":"","childs":[]},{"content":"CGA","plain":"CGA","plainChilds":"","childs":[]},{"content":"DTLS","plain":"DTLS","plainChilds":"","childs":[]},{"content":"DPD","plain":"DPD","plainChilds":"","childs":[]},{"content":"DPV","plain":"DPV","plainChilds":"","childs":[]},{"content":"DCII","plain":"DCII","plainChilds":"","childs":[]},{"content":"DK","plain":"DK","plainChilds":"","childs":[]},{"content":"EKE","plain":"EKE","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"GSI","plain":"GSI","plainChilds":"","childs":[]},{"content":"GPG","plain":"GPG","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"I2P","plain":"I2P","plainChilds":"","childs":[]},{"content":"IES","plain":"IES","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"ISAKMP","plain":"ISAKMP","plainChilds":"","childs":[]},{"content":"IPsec","plain":"IPsec","plainChilds":"","childs":[]},{"content":"KMIP","plain":"KMIP","plainChilds":"","childs":[]},{"content":"MSE","plain":"MSE","plainChilds":"","childs":[]},{"content":"OTR","plain":"OTR","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PCT","plain":"PCT","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"PHE","plain":"PHE","plainChilds":"","childs":[]},{"content":"PGP","plain":"PGP","plainChilds":"","childs":[]},{"content":"RMA","plain":"RMA","plainChilds":"","childs":[]},{"content":"RTD","plain":"RTD","plainChilds":"","childs":[]},{"content":"SCP","plain":"SCP","plainChilds":"","childs":[]},{"content":"SCVP","plain":"SCVP","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SRTP","plain":"SRTP","plainChilds":"","childs":[]},{"content":"SSH","plain":"SSH","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]},{"content":"TSP","plain":"TSP","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"VBR","plain":"VBR","plainChilds":"","childs":[]},{"content":"WPA","plain":"WPA","plainChilds":"","childs":[]},{"content":"WPS","plain":"WPS","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed. (<https://cve.circl.lu/cve/CVE-2016-2427>)\n - The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n - The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes. (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","childs":{"0":[[{"content":"- ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed. (<https://cve.circl.lu/cve/CVE-2016-2427>)\n - The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n - The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes. (<https://cve.circl.lu/cve/CVE-2007-6721>)","plain":"- ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed. (<https://cve.circl.lu/cve/CVE-2016-2427>)\n - The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n - The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes. (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Bouncy Castle - http://bouncycastle.org/","descr":"Bouncy Castle C# Fips without repository and link to archive.","License":{"plain":"- MIT\n","childs":{"0":[[{"content":"MIT","plain":"MIT\n","plainChilds":"","childs":[]}]]}},"Repository":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Description":{"plain":"This library has no repository specified.","childs":{"0":["This library has no repository specified."]}},"Interface Languages":{"plain":"- Java FIPS\n","childs":{"0":[[{"content":"Java FIPS","plain":"Java FIPS\n","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C#\n- Java\n","childs":{"0":[[{"content":"C#","plain":"C#\n","plainChilds":"","childs":[]},{"content":"Java","plain":"Java\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Release: 1.0.0\n","childs":{"0":[[{"content":"Release: 1.0.0","plain":"Release: 1.0.0\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"bouncycastle","childs":{"0":["bouncycastle"]}},"CVE Product":{"plain":"legion-of-the-bouncy-castle-java-crytography-api","childs":{"0":["legion-of-the-bouncy-castle-java-crytography-api"]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed. (<https://cve.circl.lu/cve/CVE-2016-2427>)\n - The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n - The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes. (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","childs":{"0":[[{"content":"- ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed. (<https://cve.circl.lu/cve/CVE-2016-2427>)\n - The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n - The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes. (<https://cve.circl.lu/cve/CVE-2007-6721>)","plain":"- ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed. (<https://cve.circl.lu/cve/CVE-2016-2427>)\n - The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n - The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes. (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"cryptlib - http://www.cryptlib.com/","descr":"cryptlib is an open source cross-platform software security toolkit library. It is distributed under the Sleepycat License, a free software license compatible with the GNU General Public License.[3] Alternatively, cryptlib is available under a standard commercial license for those preferring to use it under commercial terms.","License":{"plain":"- Sleepycat\n","childs":{"0":[[{"content":"Sleepycat","plain":"Sleepycat\n","plainChilds":"","childs":[]}]]}},"Repository":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Description":{"plain":"The cryptlib Security Software Development Toolkit allows even inexperienced developers to easily add world-class security services to their applications by learning a single API. cryptlib manages all your SSL, SSH, TLS, S/MIME, PGP, OpenPGP, PKI, X.509, CMP, OCSP and SCEP security requirements, and more. cryptlib was designed by security experts, but not exclusively for security experts. It is highly efficient and has been rigorously tested across a wide range of operating systems and platforms over the last 18 years. The cryptlib software has been deployed and proven in many different sectors, and our clients state that it is the only security software development toolkit youll ever need.","childs":{"0":["The cryptlib Security Software Development Toolkit allows even inexperienced developers to easily add world-class security services to their applications by learning a single API. cryptlib manages all your SSL, SSH, TLS, S/MIME, PGP, OpenPGP, PKI, X.509, CMP, OCSP and SCEP security requirements, and more. cryptlib was designed by security experts, but not exclusively for security experts. It is highly efficient and has been rigorously tested across a wide range of operating systems and platforms over the last 18 years. The cryptlib software has been deployed and proven in many different sectors, and our clients state that it is the only security software development toolkit youll ever need."]}},"Development Languages":{"plain":"- C\n","childs":{"0":[[{"content":"C","plain":"C\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Release: 3.4.3.1\n","childs":{"0":[[{"content":"Release: 3.4.3.1","plain":"Release: 3.4.3.1\n","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data).\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data).","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data).\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Botan  2.0.0 - https://botan.randombit.net/","descr":"Botan is a BSD-licensed cryptographic library written in C++. It provides a wide variety of cryptographic algorithms, formats, and protocols, e.g. SSL and TLS. It is used in the Monotone distributed revision control program, the OpenDNSSEC system, and ISC's Kea DHCP server among other projects.","License":{"plain":"- BSD-2-Clause\n","childs":{"0":[[{"content":"BSD-2-Clause","plain":"BSD-2-Clause\n","plainChilds":"","childs":[]}]]}},"Description":{"plain":"Botan's goal is to be the best option for cryptography in new C++ code by offering the tools necessary to implement a range of practical systems, such as TLS/DTLS, PKIX certificate handling, PKCS#11 and TPM hardware support, password hashing, and post quantum crypto schemes. In addition to the C++, botan has a C89 API specifically designed to be easy to call from other languages. A Python binding using ctypes is included, and several other language bindings are available.","childs":{"0":["Botan's goal is to be the best option for cryptography in new C++ code by offering the tools necessary to implement a range of practical systems, such as TLS/DTLS, PKIX certificate handling, PKCS#11 and TPM hardware support, password hashing, and post quantum crypto schemes. In addition to the C++, botan has a C89 API specifically designed to be easy to call from other languages. A Python binding using ctypes is included, and several other language bindings are available."]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/randombit/botan>\n    - Last repository change: 2018-04-11T14:04:04\n    - Last checked: 2018-04-11T20:49:21","childs":[]}]]}},"Archive":{"plain":"- https://github.com/randombit/botan/archive/2.0.0.zip\n","childs":{"0":[[{"content":"https://github.com/randombit/botan/archive/2.0.0.zip","plain":"https://github.com/randombit/botan/archive/2.0.0.zip\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C++11\n","childs":{"0":[[{"content":"C++11","plain":"C++11\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Release Date: 2017-01-07\n- Release: 2.0.0\n","childs":{"0":[[{"content":"Release Date: 2017-01-07","plain":"Release Date: 2017-01-07\n","plainChilds":"","childs":[]},{"content":"Release: 2.0.0","plain":"Release: 2.0.0","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"botan_project","childs":{"0":["botan_project"]}},"CVE Product":{"plain":"botan","childs":{"0":["botan"]}},"Development Languages":{"plain":"- C++\n- Python\n- C\n","childs":{"0":[[{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"Python","plain":"Python","plainChilds":"","childs":[]},{"content":"C","plain":"C","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"CAST-128","plain":"CAST-128","plainChilds":"","childs":[]},{"content":"CAST-256","plain":"CAST-256","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"FPE","plain":"FPE","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"KASUMI","plain":"KASUMI","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"Mercy","plain":"Mercy","plainChilds":"","childs":[]},{"content":"MISTY1","plain":"MISTY1","plainChilds":"","childs":[]},{"content":"NDS","plain":"NDS","plainChilds":"","childs":[]},{"content":"NOEKEON","plain":"NOEKEON","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"RC5","plain":"RC5","plainChilds":"","childs":[]},{"content":"SAFER","plain":"SAFER","plainChilds":"","childs":[]},{"content":"Serpent","plain":"Serpent","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"Simon","plain":"Simon","plainChilds":"","childs":[]},{"content":"Threefish","plain":"Threefish","plainChilds":"","childs":[]},{"content":"Twofish","plain":"Twofish","plainChilds":"","childs":[]},{"content":"XTEA","plain":"XTEA","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"Dragon","plain":"Dragon","plainChilds":"","childs":[]},{"content":"eSTREAM","plain":"eSTREAM","plainChilds":"","childs":[]},{"content":"LEX","plain":"LEX","plainChilds":"","childs":[]},{"content":"MAG","plain":"MAG","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]},{"content":"Turing","plain":"Turing","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SipHash","plain":"SipHash","plainChilds":"","childs":[]},{"content":"Skein","plain":"Skein","plainChilds":"","childs":[]},{"content":"Tiger","plain":"Tiger","plainChilds":"","childs":[]},{"content":"WHIRLPOOL","plain":"WHIRLPOOL","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"BPS","plain":"BPS","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"OCB","plain":"OCB","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"SIV","plain":"SIV","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"ElGamal","plain":"ElGamal","plainChilds":"","childs":[]},{"content":"McEliece","plain":"McEliece","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"Identrus","plain":"Identrus","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"PKIX","plain":"PKIX","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"AS2","plain":"AS2","plainChilds":"","childs":[]},{"content":"AKA","plain":"AKA","plainChilds":"","childs":[]},{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"CSR","plain":"CSR","plainChilds":"","childs":[]},{"content":"CMS","plain":"CMS","plainChilds":"","childs":[]},{"content":"DTLS","plain":"DTLS","plainChilds":"","childs":[]},{"content":"DPD","plain":"DPD","plainChilds":"","childs":[]},{"content":"DCII","plain":"DCII","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"GPG","plain":"GPG","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"OTR","plain":"OTR","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"PGP","plain":"PGP","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SRTP","plain":"SRTP","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- A cryptographic cache-based side channel in the RSA implementation in Botan before 1.10.17, and 1.11.x and 2.x before 2.3.0, allows a local attacker to recover information about RSA secret keys, as demonstrated by CacheD. This occurs because an array is indexed with bits derived from a secret key. (<https://cve.circl.lu/cve/CVE-2017-14737>)\n - A programming error exists in a way Randombit Botan cryptographic library version 2.0.1 implements x500 string comparisons which could lead to certificate verification issues and abuse. A specially crafted X509 certificate would need to be delivered to the client or server application in order to trigger this vulnerability. (<https://cve.circl.lu/cve/CVE-2017-2801>)\n - The X509_Certificate::allowed_usage function in botan 1.11.x before 1.11.31 might allow attackers to have unspecified impact by leveraging a call with more than one Key_Usage set in the enum value. (<https://cve.circl.lu/cve/CVE-2016-6879>)\n - The Curve25519 code in botan before 1.11.31, on systems without a native 128-bit integer type, might allow attackers to have unspecified impact via vectors related to undefined behavior, as demonstrated on 32-bit ARM systems compiled by Clang. (<https://cve.circl.lu/cve/CVE-2016-6878>)\n - botan 1.11.x before 1.11.22 makes it easier for remote attackers to decrypt TLS ciphertext data via a padding-oracle attack against TLS CBC ciphersuites. (<https://cve.circl.lu/cve/CVE-2015-7824>)\n - botan before 1.11.22 improperly validates certificate paths, which allows remote attackers to cause a denial of service (infinite loop and memory consumption) via a certificate with a loop in the certificate chain. (<https://cve.circl.lu/cve/CVE-2015-7825>)\n - botan 1.11.x before 1.11.22 improperly handles wildcard matching against hostnames, which might allow remote attackers to have unspecified impact via a valid X.509 certificate, as demonstrated by accepting *.example.com as a match for bar.foo.example.com. (<https://cve.circl.lu/cve/CVE-2015-7826>)\n - In Botan 1.8.0 through 1.11.33, when decoding BER data an integer overflow could occur, which would cause an incorrect length field to be computed. Some API callers may use the returned (incorrect and attacker controlled) length field in a way which later causes memory corruption or other failure. (<https://cve.circl.lu/cve/CVE-2016-9132>)\n - In Botan 1.11.29 through 1.11.32, RSA decryption with certain padding options had a detectable timing channel which could given sufficient queries be used to recover plaintext, aka an OAEP side channel attack. (<https://cve.circl.lu/cve/CVE-2016-8871>)\n - Botan before 1.10.13 and 1.11.x before 1.11.22 make it easier for remote attackers to conduct million-message attacks by measuring time differences, related to decoding of PKCS#1 padding. (<https://cve.circl.lu/cve/CVE-2015-7827>)\n - Botan before 1.10.13 and 1.11.x before 1.11.29 do not use a constant-time algorithm to perform a modular inverse on the signature nonce k, which might allow remote attackers to obtain ECDSA secret keys via a timing side-channel attack. (<https://cve.circl.lu/cve/CVE-2016-2849>)\n - Botan 1.11.x before 1.11.29 does not enforce TLS policy for (1) signature algorithms and (2) ECC curves, which allows remote attackers to conduct downgrade attacks via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2850>)\n - The ressol function in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (infinite loop) via unspecified input to the OS2ECP function, related to a composite modulus. (<https://cve.circl.lu/cve/CVE-2016-2194>)\n - Integer overflow in the PointGFp constructor in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to overwrite memory and possibly execute arbitrary code via a crafted ECC point, which triggers a heap-based buffer overflow. (<https://cve.circl.lu/cve/CVE-2016-2195>)\n - Heap-based buffer overflow in the P-521 reduction function in Botan 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (memory overwrite and crash) or execute arbitrary code via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2196>)\n - The BER decoder in Botan 0.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (application crash) via an empty BIT STRING in ASN.1 data. (<https://cve.circl.lu/cve/CVE-2015-5726>)\n - The Miller-Rabin primality check in Botan before 1.10.8 and 1.11.x before 1.11.9 improperly uses a single random base, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via a DH group. (<https://cve.circl.lu/cve/CVE-2014-9742>)\n - The BER decoder in Botan 1.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (memory consumption) via unspecified vectors, related to a length field. (<https://cve.circl.lu/cve/CVE-2015-5727>)\u0000","childs":{"0":[[{"content":"- A cryptographic cache-based side channel in the RSA implementation in Botan before 1.10.17, and 1.11.x and 2.x before 2.3.0, allows a local attacker to recover information about RSA secret keys, as demonstrated by CacheD. This occurs because an array is indexed with bits derived from a secret key. (<https://cve.circl.lu/cve/CVE-2017-14737>)\n - A programming error exists in a way Randombit Botan cryptographic library version 2.0.1 implements x500 string comparisons which could lead to certificate verification issues and abuse. A specially crafted X509 certificate would need to be delivered to the client or server application in order to trigger this vulnerability. (<https://cve.circl.lu/cve/CVE-2017-2801>)\n - The X509_Certificate::allowed_usage function in botan 1.11.x before 1.11.31 might allow attackers to have unspecified impact by leveraging a call with more than one Key_Usage set in the enum value. (<https://cve.circl.lu/cve/CVE-2016-6879>)\n - The Curve25519 code in botan before 1.11.31, on systems without a native 128-bit integer type, might allow attackers to have unspecified impact via vectors related to undefined behavior, as demonstrated on 32-bit ARM systems compiled by Clang. (<https://cve.circl.lu/cve/CVE-2016-6878>)\n - botan 1.11.x before 1.11.22 makes it easier for remote attackers to decrypt TLS ciphertext data via a padding-oracle attack against TLS CBC ciphersuites. (<https://cve.circl.lu/cve/CVE-2015-7824>)\n - botan before 1.11.22 improperly validates certificate paths, which allows remote attackers to cause a denial of service (infinite loop and memory consumption) via a certificate with a loop in the certificate chain. (<https://cve.circl.lu/cve/CVE-2015-7825>)\n - botan 1.11.x before 1.11.22 improperly handles wildcard matching against hostnames, which might allow remote attackers to have unspecified impact via a valid X.509 certificate, as demonstrated by accepting *.example.com as a match for bar.foo.example.com. (<https://cve.circl.lu/cve/CVE-2015-7826>)\n - In Botan 1.8.0 through 1.11.33, when decoding BER data an integer overflow could occur, which would cause an incorrect length field to be computed. Some API callers may use the returned (incorrect and attacker controlled) length field in a way which later causes memory corruption or other failure. (<https://cve.circl.lu/cve/CVE-2016-9132>)\n - In Botan 1.11.29 through 1.11.32, RSA decryption with certain padding options had a detectable timing channel which could given sufficient queries be used to recover plaintext, aka an OAEP side channel attack. (<https://cve.circl.lu/cve/CVE-2016-8871>)\n - Botan before 1.10.13 and 1.11.x before 1.11.22 make it easier for remote attackers to conduct million-message attacks by measuring time differences, related to decoding of PKCS#1 padding. (<https://cve.circl.lu/cve/CVE-2015-7827>)\n - Botan before 1.10.13 and 1.11.x before 1.11.29 do not use a constant-time algorithm to perform a modular inverse on the signature nonce k, which might allow remote attackers to obtain ECDSA secret keys via a timing side-channel attack. (<https://cve.circl.lu/cve/CVE-2016-2849>)\n - Botan 1.11.x before 1.11.29 does not enforce TLS policy for (1) signature algorithms and (2) ECC curves, which allows remote attackers to conduct downgrade attacks via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2850>)\n - The ressol function in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (infinite loop) via unspecified input to the OS2ECP function, related to a composite modulus. (<https://cve.circl.lu/cve/CVE-2016-2194>)\n - Integer overflow in the PointGFp constructor in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to overwrite memory and possibly execute arbitrary code via a crafted ECC point, which triggers a heap-based buffer overflow. (<https://cve.circl.lu/cve/CVE-2016-2195>)\n - Heap-based buffer overflow in the P-521 reduction function in Botan 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (memory overwrite and crash) or execute arbitrary code via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2196>)\n - The BER decoder in Botan 0.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (application crash) via an empty BIT STRING in ASN.1 data. (<https://cve.circl.lu/cve/CVE-2015-5726>)\n - The Miller-Rabin primality check in Botan before 1.10.8 and 1.11.x before 1.11.9 improperly uses a single random base, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via a DH group. (<https://cve.circl.lu/cve/CVE-2014-9742>)\n - The BER decoder in Botan 1.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (memory consumption) via unspecified vectors, related to a length field. (<https://cve.circl.lu/cve/CVE-2015-5727>)","plain":"- A cryptographic cache-based side channel in the RSA implementation in Botan before 1.10.17, and 1.11.x and 2.x before 2.3.0, allows a local attacker to recover information about RSA secret keys, as demonstrated by CacheD. This occurs because an array is indexed with bits derived from a secret key. (<https://cve.circl.lu/cve/CVE-2017-14737>)\n - A programming error exists in a way Randombit Botan cryptographic library version 2.0.1 implements x500 string comparisons which could lead to certificate verification issues and abuse. A specially crafted X509 certificate would need to be delivered to the client or server application in order to trigger this vulnerability. (<https://cve.circl.lu/cve/CVE-2017-2801>)\n - The X509_Certificate::allowed_usage function in botan 1.11.x before 1.11.31 might allow attackers to have unspecified impact by leveraging a call with more than one Key_Usage set in the enum value. (<https://cve.circl.lu/cve/CVE-2016-6879>)\n - The Curve25519 code in botan before 1.11.31, on systems without a native 128-bit integer type, might allow attackers to have unspecified impact via vectors related to undefined behavior, as demonstrated on 32-bit ARM systems compiled by Clang. (<https://cve.circl.lu/cve/CVE-2016-6878>)\n - botan 1.11.x before 1.11.22 makes it easier for remote attackers to decrypt TLS ciphertext data via a padding-oracle attack against TLS CBC ciphersuites. (<https://cve.circl.lu/cve/CVE-2015-7824>)\n - botan before 1.11.22 improperly validates certificate paths, which allows remote attackers to cause a denial of service (infinite loop and memory consumption) via a certificate with a loop in the certificate chain. (<https://cve.circl.lu/cve/CVE-2015-7825>)\n - botan 1.11.x before 1.11.22 improperly handles wildcard matching against hostnames, which might allow remote attackers to have unspecified impact via a valid X.509 certificate, as demonstrated by accepting *.example.com as a match for bar.foo.example.com. (<https://cve.circl.lu/cve/CVE-2015-7826>)\n - In Botan 1.8.0 through 1.11.33, when decoding BER data an integer overflow could occur, which would cause an incorrect length field to be computed. Some API callers may use the returned (incorrect and attacker controlled) length field in a way which later causes memory corruption or other failure. (<https://cve.circl.lu/cve/CVE-2016-9132>)\n - In Botan 1.11.29 through 1.11.32, RSA decryption with certain padding options had a detectable timing channel which could given sufficient queries be used to recover plaintext, aka an OAEP side channel attack. (<https://cve.circl.lu/cve/CVE-2016-8871>)\n - Botan before 1.10.13 and 1.11.x before 1.11.22 make it easier for remote attackers to conduct million-message attacks by measuring time differences, related to decoding of PKCS#1 padding. (<https://cve.circl.lu/cve/CVE-2015-7827>)\n - Botan before 1.10.13 and 1.11.x before 1.11.29 do not use a constant-time algorithm to perform a modular inverse on the signature nonce k, which might allow remote attackers to obtain ECDSA secret keys via a timing side-channel attack. (<https://cve.circl.lu/cve/CVE-2016-2849>)\n - Botan 1.11.x before 1.11.29 does not enforce TLS policy for (1) signature algorithms and (2) ECC curves, which allows remote attackers to conduct downgrade attacks via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2850>)\n - The ressol function in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (infinite loop) via unspecified input to the OS2ECP function, related to a composite modulus. (<https://cve.circl.lu/cve/CVE-2016-2194>)\n - Integer overflow in the PointGFp constructor in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to overwrite memory and possibly execute arbitrary code via a crafted ECC point, which triggers a heap-based buffer overflow. (<https://cve.circl.lu/cve/CVE-2016-2195>)\n - Heap-based buffer overflow in the P-521 reduction function in Botan 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (memory overwrite and crash) or execute arbitrary code via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2196>)\n - The BER decoder in Botan 0.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (application crash) via an empty BIT STRING in ASN.1 data. (<https://cve.circl.lu/cve/CVE-2015-5726>)\n - The Miller-Rabin primality check in Botan before 1.10.8 and 1.11.x before 1.11.9 improperly uses a single random base, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via a DH group. (<https://cve.circl.lu/cve/CVE-2014-9742>)\n - The BER decoder in Botan 1.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (memory consumption) via unspecified vectors, related to a length field. (<https://cve.circl.lu/cve/CVE-2015-5727>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Bouncy Castle - http://bouncycastle.org/","descr":"Bouncy Castle is a collection of APIs used in cryptography. It includes APIs for both the Java and the C# programming languages. The APIs are supported by a registered Australian charitable organization: Legion of the Bouncy Castle Inc.","License":{"plain":"- MIT\n","childs":{"0":[[{"content":"MIT","plain":"MIT\n","plainChilds":"","childs":[]}]]}},"Description":{"plain":"The Bouncy Castle Crypto package is a C# implementation of cryptographic algorithms and protocols, it was developed by the Legion of the Bouncy Castle, a registered Australian Charity, with a little help! The Legion, and the latest goings on with this package, can be found at http://www.bouncycastle.org. In addition to providing basic cryptography algorithms, the package also provides support for CMS, TSP, X.509 certificate generation and a variety of other standards such as OpenPGP.","childs":{"0":["The Bouncy Castle Crypto package is a C# implementation of cryptographic algorithms and protocols, it was developed by the Legion of the Bouncy Castle, a registered Australian Charity, with a little help! The Legion, and the latest goings on with this package, can be found at http://www.bouncycastle.org. In addition to providing basic cryptography algorithms, the package also provides support for CMS, TSP, X.509 certificate generation and a variety of other standards such as OpenPGP."]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/bcgit/bc-csharp>\n    - Last repository change: 2018-04-08T16:17:23\n    - Last checked: 2018-04-11T20:49:21","childs":[]}]]}},"Interface Languages":{"plain":"- C#\n","childs":{"0":[[{"content":"C#","plain":"C#\n","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C#\n- Java\n","childs":{"0":[[{"content":"C#","plain":"C#\n","plainChilds":"","childs":[]},{"content":"Java","plain":"Java\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"bouncycastle","childs":{"0":["bouncycastle"]}},"CVE Product":{"plain":"legion-of-the-bouncy-castle-java-crytography-api","childs":{"0":["legion-of-the-bouncy-castle-java-crytography-api"]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 409\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 409","plain":"Stars: 409","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"3-Way","plain":"3-Way","plainChilds":"","childs":[]},{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"DFC","plain":"DFC","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"IDEA NXT","plain":"IDEA NXT","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"MMB","plain":"MMB","plainChilds":"","childs":[]},{"content":"NDS","plain":"NDS","plainChilds":"","childs":[]},{"content":"NOEKEON","plain":"NOEKEON","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"RC2","plain":"RC2","plainChilds":"","childs":[]},{"content":"RC5","plain":"RC5","plainChilds":"","childs":[]},{"content":"RC6","plain":"RC6","plainChilds":"","childs":[]},{"content":"Serpent","plain":"Serpent","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"SM4","plain":"SM4","plainChilds":"","childs":[]},{"content":"Threefish","plain":"Threefish","plainChilds":"","childs":[]},{"content":"TEA","plain":"TEA","plainChilds":"","childs":[]},{"content":"3DES","plain":"3DES","plainChilds":"","childs":[]},{"content":"Twofish","plain":"Twofish","plainChilds":"","childs":[]},{"content":"UES","plain":"UES","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"eSTREAM","plain":"eSTREAM","plainChilds":"","childs":[]},{"content":"ISAAC","plain":"ISAAC","plainChilds":"","childs":[]},{"content":"LEX","plain":"LEX","plainChilds":"","childs":[]},{"content":"MAG","plain":"MAG","plainChilds":"","childs":[]},{"content":"Py","plain":"Py","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]},{"content":"ZUC","plain":"ZUC","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"FSB","plain":"FSB","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"MD6","plain":"MD6","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SipHash","plain":"SipHash","plainChilds":"","childs":[]},{"content":"Skein","plain":"Skein","plainChilds":"","childs":[]},{"content":"WHIRLPOOL","plain":"WHIRLPOOL","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IGE","plain":"IGE","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"OCB","plain":"OCB","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"RAC","plain":"RAC","plainChilds":"","childs":[]},{"content":"RKC","plain":"RKC","plainChilds":"","childs":[]},{"content":"SIV","plain":"SIV","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"OMAC","plain":"OMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"LUC","plain":"LUC","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]},{"content":"YAK","plain":"YAK","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"LDAP","plain":"LDAP","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"PKIX","plain":"PKIX","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"AS1","plain":"AS1","plainChilds":"","childs":[]},{"content":"AKA","plain":"AKA","plainChilds":"","childs":[]},{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"CSR","plain":"CSR","plainChilds":"","childs":[]},{"content":"CMS","plain":"CMS","plainChilds":"","childs":[]},{"content":"DTLS","plain":"DTLS","plainChilds":"","childs":[]},{"content":"DPD","plain":"DPD","plainChilds":"","childs":[]},{"content":"DPV","plain":"DPV","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"GPG","plain":"GPG","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"I2P","plain":"I2P","plainChilds":"","childs":[]},{"content":"IES","plain":"IES","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"ISAKMP","plain":"ISAKMP","plainChilds":"","childs":[]},{"content":"IPsec","plain":"IPsec","plainChilds":"","childs":[]},{"content":"MSE","plain":"MSE","plainChilds":"","childs":[]},{"content":"OTR","plain":"OTR","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"PHE","plain":"PHE","plainChilds":"","childs":[]},{"content":"PGP","plain":"PGP","plainChilds":"","childs":[]},{"content":"RTD","plain":"RTD","plainChilds":"","childs":[]},{"content":"SCVP","plain":"SCVP","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SRTP","plain":"SRTP","plainChilds":"","childs":[]},{"content":"SSH","plain":"SSH","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]},{"content":"TSP","plain":"TSP","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"VBR","plain":"VBR","plainChilds":"","childs":[]},{"content":"WPA","plain":"WPA","plainChilds":"","childs":[]},{"content":"WPS","plain":"WPS","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed. (<https://cve.circl.lu/cve/CVE-2016-2427>)\n - The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n - The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes. (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","childs":{"0":[[{"content":"- ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed. (<https://cve.circl.lu/cve/CVE-2016-2427>)\n - The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n - The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes. (<https://cve.circl.lu/cve/CVE-2007-6721>)","plain":"- ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed. (<https://cve.circl.lu/cve/CVE-2016-2427>)\n - The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n - The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes. (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Template - http://www.example.com","descr":"Default short description","Description":{"plain":"Default long description in __markdown__.","childs":{"0":["Default long description in __markdown__."]}},"Repository":{"plain":"- Not Sure\n","childs":{"0":[[{"content":"Not Sure","plain":"Not Sure\n","plainChilds":"    - <https://github.com/SitOPT/SitOPT-Installation-Script>\n    - Last repository change: 2018-02-20T08:43:50\n    - Last checked: 2018-04-11T20:49:21","childs":[]}]]}},"Archive":{"plain":"- https://github.com/example/example/archive/1.0.0.zip\n","childs":{"0":[[{"content":"https://github.com/example/example/archive/1.0.0.zip","plain":"https://github.com/example/example/archive/1.0.0.zip\n","plainChilds":"","childs":[]}]]}},"License":{"plain":"- MIT\n- Apache-2.0\n- MPL-2.0\n","childs":{"0":[[{"content":"MIT","plain":"MIT\n","plainChilds":"","childs":[]},{"content":"Apache-2.0","plain":"Apache-2.0\n","plainChilds":"","childs":[]},{"content":"MPL-2.0","plain":"MPL-2.0\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Release: 1.0.0\n- Release Date: Today\n","childs":{"0":[[{"content":"Release: 1.0.0","plain":"Release: 1.0.0\n","plainChilds":"","childs":[]},{"content":"Release Date: Today","plain":"Release Date: Today\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C++\n- Java\n","childs":{"0":[[{"content":"C++","plain":"C++\n","plainChilds":"","childs":[]},{"content":"Java","plain":"Java\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"template-vendor","childs":{"0":["template-vendor"]}},"CVE Product":{"plain":"template-product","childs":{"0":["template-product"]}},"Development Languages":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data).\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data).","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data).\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"OpenSSL - www.openssl.org","descr":"OpenSSL is a software library for applications that secure communications over computer networks against eavesdropping or need to identify the party at the other end. It is widely used in internet web servers, serving a majority of all web sites.","License":{"plain":"- Apache-1.0\n- BSD-4-Clause\n","childs":{"0":[[{"content":"Apache-1.0","plain":"Apache-1.0\n","plainChilds":"","childs":[]},{"content":"BSD-4-Clause","plain":"BSD-4-Clause\n","plainChilds":"","childs":[]}]]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/openssl/openssl>\n    - Last repository change: 2018-04-11T14:07:38\n    - Last checked: 2018-04-11T20:49:21","childs":[]}]]}},"CVE Vendor":{"plain":"openssl","childs":{"0":["openssl"]}},"CVE Product":{"plain":"openssl","childs":{"0":["openssl"]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 6808\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 6808","plain":"Stars: 6808","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C\n- C++\n- Python\n","childs":{"0":[[{"content":"C","plain":"C","plainChilds":"","childs":[]},{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"Python","plain":"Python","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"3-Way","plain":"3-Way","plainChilds":"","childs":[]},{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"ARIA","plain":"ARIA","plainChilds":"","childs":[]},{"content":"ARIA-128","plain":"ARIA-128","plainChilds":"","childs":[]},{"content":"ARIA-192","plain":"ARIA-192","plainChilds":"","childs":[]},{"content":"ARIA-256","plain":"ARIA-256","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"CDMF","plain":"CDMF","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"FEAL","plain":"FEAL","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"IDEA NXT","plain":"IDEA NXT","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"MESH","plain":"MESH","plainChilds":"","childs":[]},{"content":"MMB","plain":"MMB","plainChilds":"","childs":[]},{"content":"NOEKEON","plain":"NOEKEON","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"RC2","plain":"RC2","plainChilds":"","childs":[]},{"content":"RC5","plain":"RC5","plainChilds":"","childs":[]},{"content":"RC6","plain":"RC6","plainChilds":"","childs":[]},{"content":"SAFER","plain":"SAFER","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"SM4","plain":"SM4","plainChilds":"","childs":[]},{"content":"3DES","plain":"3DES","plainChilds":"","childs":[]},{"content":"UES","plain":"UES","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"Crypto1","plain":"Crypto1","plainChilds":"","childs":[]},{"content":"Dragon","plain":"Dragon","plainChilds":"","childs":[]},{"content":"FISH","plain":"FISH","plainChilds":"","childs":[]},{"content":"LEX","plain":"LEX","plainChilds":"","childs":[]},{"content":"MAG","plain":"MAG","plainChilds":"","childs":[]},{"content":"Py","plain":"Py","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]},{"content":"SEAL","plain":"SEAL","plainChilds":"","childs":[]},{"content":"Turing","plain":"Turing","plainChilds":"","childs":[]},{"content":"Vernam","plain":"Vernam","plainChilds":"","childs":[]},{"content":"VEST","plain":"VEST","plainChilds":"","childs":[]},{"content":"WAKE","plain":"WAKE","plainChilds":"","childs":[]},{"content":"ZUC","plain":"ZUC","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"MD6","plain":"MD6","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SHAKE","plain":"SHAKE","plainChilds":"","childs":[]},{"content":"SipHash","plain":"SipHash","plainChilds":"","childs":[]},{"content":"WHIRLPOOL","plain":"WHIRLPOOL","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"BPS","plain":"BPS","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"CWC","plain":"CWC","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IGE","plain":"IGE","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"OCB","plain":"OCB","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"PCBC","plain":"PCBC","plainChilds":"","childs":[]},{"content":"RAC","plain":"RAC","plainChilds":"","childs":[]},{"content":"SIV","plain":"SIV","plainChilds":"","childs":[]},{"content":"XBC","plain":"XBC","plainChilds":"","childs":[]},{"content":"XCBC","plain":"XCBC","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]},{"content":"TMAC","plain":"TMAC","plainChilds":"","childs":[]},{"content":"XCBC","plain":"XCBC","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"DVCS","plain":"DVCS","plainChilds":"","childs":[]},{"content":"LDAP","plain":"LDAP","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"OpenCA","plain":"OpenCA","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"PKIX","plain":"PKIX","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"AS2","plain":"AS2","plainChilds":"","childs":[]},{"content":"AKA","plain":"AKA","plainChilds":"","childs":[]},{"content":"CMC","plain":"CMC","plainChilds":"","childs":[]},{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"CSR","plain":"CSR","plainChilds":"","childs":[]},{"content":"CMS","plain":"CMS","plainChilds":"","childs":[]},{"content":"DTLS","plain":"DTLS","plainChilds":"","childs":[]},{"content":"DPD","plain":"DPD","plainChilds":"","childs":[]},{"content":"DCII","plain":"DCII","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"GSI","plain":"GSI","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IES","plain":"IES","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"IPsec","plain":"IPsec","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PCT","plain":"PCT","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"PHE","plain":"PHE","plainChilds":"","childs":[]},{"content":"PoSE","plain":"PoSE","plainChilds":"","childs":[]},{"content":"RTD","plain":"RTD","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SRTP","plain":"SRTP","plainChilds":"","childs":[]},{"content":"SSH","plain":"SSH","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]},{"content":"TSP","plain":"TSP","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"WPA","plain":"WPA","plainChilds":"","childs":[]},{"content":"WPS","plain":"WPS","plainChilds":"","childs":[]},{"content":"WTLS","plain":"WTLS","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- There is an overflow bug in the AVX2 Montgomery multiplication procedure used in exponentiation with 1024-bit moduli. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH1024 are considered just feasible, because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH1024 private key among multiple clients, which is no longer an option since CVE-2016-0701. This only affects processors that support the AVX2 but not ADX extensions like Intel Haswell (4th generation). Note: The impact from this issue is similar to CVE-2017-3736, CVE-2017-3732 and CVE-2015-3193. OpenSSL version 1.0.2-1.0.2m and 1.1.0-1.1.0g are affected. Fixed in OpenSSL 1.0.2n. Due to the low severity of this issue we are not issuing a new release of OpenSSL 1.1.0 at this time. The fix will be included in OpenSSL 1.1.0h when it becomes available. The fix is also available in commit e502cc86d in the OpenSSL git repository. (<https://cve.circl.lu/cve/CVE-2017-3738>)\n - OpenSSL 1.0.2 (starting from version 1.0.2b) introduced an error state mechanism. The intent was that if a fatal error occurred during a handshake then OpenSSL would move into the error state and would immediately fail if you attempted to continue the handshake. This works as designed for the explicit handshake functions (SSL_do_handshake(), SSL_accept() and SSL_connect()), however due to a bug it does not work correctly if SSL_read() or SSL_write() is called directly. In that scenario, if the handshake fails then a fatal error will be returned in the initial function call. If SSL_read()/SSL_write() is subsequently called by the application for the same SSL object then it will succeed and the data is passed without being decrypted/encrypted directly from the SSL/TLS record layer. In order to exploit this issue an application bug would have to be present that resulted in a call to SSL_read()/SSL_write() being issued after having already received a fatal error. OpenSSL version 1.0.2b-1.0.2m are affected. Fixed in OpenSSL 1.0.2n. OpenSSL 1.1.0 is not affected. (<https://cve.circl.lu/cve/CVE-2017-3737>)\n - A denial of service flaw was found in OpenSSL 0.9.8, 1.0.1, 1.0.2 through 1.0.2h, and 1.1.0 in the way the TLS/SSL protocol defined processing of ALERT packets during a connection handshake. A remote attacker could use this flaw to make a TLS/SSL server consume an excessive amount of CPU and fail to accept connections from other clients. (<https://cve.circl.lu/cve/CVE-2016-8610>)\n - There is a carry propagating bug in the x86_64 Montgomery squaring procedure in OpenSSL before 1.0.2m and 1.1.0 before 1.1.0g. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. This only affects processors that support the BMI1, BMI2 and ADX extensions like Intel Broadwell (5th generation) and later or AMD Ryzen. (<https://cve.circl.lu/cve/CVE-2017-3736>)\n - While parsing an IPAddressFamily extension in an X.509 certificate, it is possible to do a one-byte overread. This would result in an incorrect text display of the certificate. This bug has been present since 2006 and is present in all versions of OpenSSL before 1.0.2m and 1.1.0g. (<https://cve.circl.lu/cve/CVE-2017-3735>)\n - During a renegotiation handshake if the Encrypt-Then-Mac extension is negotiated where it was not in the original handshake (or vice-versa) then this can cause OpenSSL 1.1.0 before 1.1.0e to crash (dependent on ciphersuite). Both clients and servers are affected. (<https://cve.circl.lu/cve/CVE-2017-3733>)\n - The doapr_outch function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not verify that a certain memory allocation succeeds, which allows remote attackers to cause a denial of service (out-of-bounds write or memory consumption) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-0799. (<https://cve.circl.lu/cve/CVE-2016-2842>)\n - The DES and Triple DES ciphers, as used in the TLS, SSH, and IPSec protocols and other protocols and products, have a birthday bound of approximately four billion blocks, which makes it easier for remote attackers to obtain cleartext data via a birthday attack against a long-duration encrypted session, as demonstrated by an HTTPS session using Triple DES in CBC mode, aka a Sweet32 attack. (<https://cve.circl.lu/cve/CVE-2016-2183>)\n - The ASN.1 implementation in OpenSSL before 1.0.1o and 1.0.2 before 1.0.2c allows remote attackers to execute arbitrary code or cause a denial of service (buffer underflow and memory corruption) via an ANY field in crafted serialized data, aka the negative zero issue. (<https://cve.circl.lu/cve/CVE-2016-2108>)\n - The AES-NI implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h does not consider memory allocation during a certain padding check, which allows remote attackers to obtain sensitive cleartext information via a padding-oracle attack against an AES CBC session. NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2016-2107>)\n - The SSLv2 protocol, as used in OpenSSL before 1.0.1s and 1.0.2 before 1.0.2g and other products, requires a server to send a ServerVerify message before establishing that a client possesses certain plaintext RSA data, which makes it easier for remote attackers to decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, aka a DROWN attack. (<https://cve.circl.lu/cve/CVE-2016-0800>)\n - The fmtstr function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g improperly calculates string lengths, which allows remote attackers to cause a denial of service (overflow and out-of-bounds read) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-2842. (<https://cve.circl.lu/cve/CVE-2016-0799>)\n - Memory leak in the SRP_VBASE_get_by_user implementation in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory consumption) by providing an invalid username in a connection attempt, related to apps/s_server.c and crypto/srp/srp_vfy.c. (<https://cve.circl.lu/cve/CVE-2016-0798>)\n - Multiple integer overflows in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allow remote attackers to cause a denial of service (heap memory corruption or NULL pointer dereference) or possibly have unspecified other impact via a long digit string that is mishandled by the (1) BN_dec2bn or (2) BN_hex2bn function, related to crypto/bn/bn.h and crypto/bn/bn_print.c. (<https://cve.circl.lu/cve/CVE-2016-0797>)\n - Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (<https://cve.circl.lu/cve/CVE-2016-0705>)\n - An oracle protection mechanism in the get_client_master_key function in s2_srvr.c in the SSLv2 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a overwrites incorrect MASTER-KEY bytes during use of export cipher suites, which makes it easier for remote attackers to decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, a related issue to CVE-2016-0800. (<https://cve.circl.lu/cve/CVE-2016-0704>)\n - The get_client_master_key function in s2_srvr.c in the SSLv2 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a accepts a nonzero CLIENT-MASTER-KEY CLEAR-KEY-LENGTH value for an arbitrary cipher, which allows man-in-the-middle attackers to determine the MASTER-KEY value and decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, a related issue to CVE-2016-0800. (<https://cve.circl.lu/cve/CVE-2016-0703>)\n - The MOD_EXP_CTIME_COPY_FROM_PREBUF function in crypto/bn/bn_exp.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not properly consider cache-bank access times during modular exponentiation, which makes it easier for local users to discover RSA keys by running a crafted application on the same Intel Sandy Bridge CPU core as a victim and leveraging cache-bank conflicts, aka a CacheBleed attack. (<https://cve.circl.lu/cve/CVE-2016-0702>)\n - The DH_check_pub_key function in crypto/dh/dh_check.c in OpenSSL 1.0.2 before 1.0.2f does not ensure that prime numbers are appropriate for Diffie-Hellman (DH) key exchange, which makes it easier for remote attackers to discover a private DH exponent by making multiple handshakes with a peer that chose an inappropriate number, as demonstrated by a number in an X9.42 file. (<https://cve.circl.lu/cve/CVE-2016-0701>)\n - ssl/s2_srvr.c in OpenSSL 1.0.1 before 1.0.1r and 1.0.2 before 1.0.2f does not prevent use of disabled ciphers, which makes it easier for man-in-the-middle attackers to defeat cryptographic protection mechanisms by performing computations on SSLv2 traffic, related to the get_client_master_key and get_client_hello functions. (<https://cve.circl.lu/cve/CVE-2015-3197>)\n - ssl/s3_clnt.c in OpenSSL 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1p, and 1.0.2 before 1.0.2d, when used for a multi-threaded client, writes the PSK identity hint to an incorrect data structure, which allows remote servers to cause a denial of service (race condition and double free) via a crafted ServerKeyExchange message. (<https://cve.circl.lu/cve/CVE-2015-3196>)\n - The ASN1_TFLG_COMBINE implementation in crypto/asn1/tasn_dec.c in OpenSSL before 0.9.8zh, 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1q, and 1.0.2 before 1.0.2e mishandles errors caused by malformed X509_ATTRIBUTE data, which allows remote attackers to obtain sensitive information from process memory by triggering a decoding failure in a PKCS#7 or CMS application. (<https://cve.circl.lu/cve/CVE-2015-3195>)\n - crypto/rsa/rsa_ameth.c in OpenSSL 1.0.1 before 1.0.1q and 1.0.2 before 1.0.2e allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an RSA PSS ASN.1 signature that lacks a mask generation function parameter. (<https://cve.circl.lu/cve/CVE-2015-3194>)\n - The Montgomery squaring implementation in crypto/bn/asm/x86_64-mont5.pl in OpenSSL 1.0.2 before 1.0.2e on the x86_64 platform, as used by the BN_mod_exp function, mishandles carry propagation and produces incorrect output, which makes it easier for remote attackers to obtain sensitive private-key information via an attack against use of a (1) Diffie-Hellman (DH) or (2) Diffie-Hellman Ephemeral (DHE) ciphersuite. (<https://cve.circl.lu/cve/CVE-2015-3193>)\n - The ssl3_get_key_exchange function in ssl/s3_clnt.c in OpenSSL 1.0.2 before 1.0.2e allows remote servers to cause a denial of service (segmentation fault) via a zero p value in an anonymous Diffie-Hellman (DH) ServerKeyExchange message. (<https://cve.circl.lu/cve/CVE-2015-1794>)\n - There is a carry propagating bug in the x86_64 Montgomery squaring procedure in OpenSSL 1.0.2 before 1.0.2k and 1.1.0 before 1.1.0d. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. For example this can occur by default in OpenSSL DHE based SSL/TLS ciphersuites. Note: This issue is very similar to CVE-2015-3193 but must be treated as a separate problem. (<https://cve.circl.lu/cve/CVE-2017-3732>)\n - If an SSL/TLS server or client is running on a 32-bit host, and a specific cipher is being used, then a truncated packet can cause that server or client to perform an out-of-bounds read, usually resulting in a crash. For OpenSSL 1.1.0, the crash can be triggered when using CHACHA20/POLY1305; users should upgrade to 1.1.0d. For Openssl 1.0.2, the crash can be triggered when using RC4-MD5; users who have not disabled that algorithm should update to 1.0.2k. (<https://cve.circl.lu/cve/CVE-2017-3731>)\n - In OpenSSL 1.1.0 before 1.1.0d, if a malicious server supplies bad parameters for a DHE or ECDHE key exchange then this can result in the client attempting to dereference a NULL pointer leading to a client crash. This could be exploited in a Denial of Service attack. (<https://cve.circl.lu/cve/CVE-2017-3730>)\n - There is a carry propagating bug in the Broadwell-specific Montgomery multiplication procedure in OpenSSL 1.0.2 and 1.1.0 before 1.1.0c that handles input lengths divisible by, but longer than 256 bits. Analysis suggests that attacks against RSA, DSA and DH private keys are impossible. This is because the subroutine in question is not used in operations with the private key itself and an input of the attacker's direct choice. Otherwise the bug can manifest itself as transient authentication and key negotiation failures or reproducible erroneous outcome of public-key operations with specially crafted input. Among EC algorithms only Brainpool P-512 curves are affected and one presumably can attack ECDH key negotiation. Impact was not analyzed in detail, because pre-requisites for attack are considered unlikely. Namely multiple clients have to choose the curve in question and the server has to share the private key among them, neither of which is default behaviour. Even then only clients that chose the curve will be affected. (<https://cve.circl.lu/cve/CVE-2016-7055>)\n - In OpenSSL 1.1.0 before 1.1.0c, TLS connections using *-CHACHA20-POLY1305 ciphersuites are susceptible to a DoS attack by corrupting larger payloads. This can result in an OpenSSL crash. This issue is not considered to be exploitable beyond a DoS. (<https://cve.circl.lu/cve/CVE-2016-7054>)\n - In OpenSSL 1.1.0 before 1.1.0c, applications parsing invalid CMS structures can crash with a NULL pointer dereference. This is caused by a bug in the handling of the ASN.1 CHOICE type in OpenSSL 1.1.0 which can result in a NULL value being passed to the structure callback if an attempt is made to free certain invalid encodings. Only CHOICE structures using a callback which do not handle NULL value are affected. (<https://cve.circl.lu/cve/CVE-2016-7053>)\n - The SSL protocol 3.0, as used in OpenSSL through 1.0.1i and other products, uses nondeterministic CBC padding, which makes it easier for man-in-the-middle attackers to obtain cleartext data via a padding-oracle attack, aka the POODLE issue. (<https://cve.circl.lu/cve/CVE-2014-3566>)\n - The BN_bn2dec function in crypto/bn/bn_print.c in OpenSSL before 1.1.0 does not properly validate division results, which allows remote attackers to cause a denial of service (out-of-bounds write and application crash) or possibly have unspecified other impact via unknown vectors. (<https://cve.circl.lu/cve/CVE-2016-2182>)\n - The X509_NAME_oneline function in crypto/x509/x509_obj.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to obtain sensitive information from process stack memory or cause a denial of service (buffer over-read) via crafted EBCDIC ASN.1 data. (<https://cve.circl.lu/cve/CVE-2016-2176>)\n - The asn1_d2i_read_bio function in crypto/asn1/a_d2i_fp.c in the ASN.1 BIO implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (memory consumption) via a short invalid encoding. (<https://cve.circl.lu/cve/CVE-2016-2109>)\n - Integer overflow in the EVP_EncryptUpdate function in crypto/evp/evp_enc.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of data. (<https://cve.circl.lu/cve/CVE-2016-2106>)\n - Integer overflow in the EVP_EncodeUpdate function in crypto/evp/encode.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of binary data. (<https://cve.circl.lu/cve/CVE-2016-2105>)\n - The dsa_sign_setup function in crypto/dsa/dsa_ossl.c in OpenSSL through 1.0.2h does not properly ensure the use of constant-time operations, which makes it easier for local users to discover a DSA private key via a timing side-channel attack. (<https://cve.circl.lu/cve/CVE-2016-2178>)\n - OpenSSL through 1.0.2h incorrectly uses pointer arithmetic for heap-buffer boundary checks, which might allow remote attackers to cause a denial of service (integer overflow and application crash) or possibly have unspecified other impact by leveraging unexpected malloc behavior, related to s3_srvr.c, ssl_sess.c, and t1_lib.c. (<https://cve.circl.lu/cve/CVE-2016-2177>)\n - The tls_decrypt_ticket function in ssl/t1_lib.c in OpenSSL before 1.1.0 does not consider the HMAC size during validation of the ticket length, which allows remote attackers to cause a denial of service via a ticket that is too short. (<https://cve.circl.lu/cve/CVE-2016-6302>)\n - The Anti-Replay feature in the DTLS implementation in OpenSSL before 1.1.0 mishandles early use of a new epoch number in conjunction with a large sequence number, which allows remote attackers to cause a denial of service (false-positive packet drops) via spoofed DTLS records, related to rec_layer_d1.c and ssl3_record.c. (<https://cve.circl.lu/cve/CVE-2016-2181>)\n - The TS_OBJ_print_bio function in crypto/ts/ts_lib.c in the X.509 Public Key Infrastructure Time-Stamp Protocol (TSP) implementation in OpenSSL through 1.0.2h allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted time-stamp file that is mishandled by the openssl ts command. (<https://cve.circl.lu/cve/CVE-2016-2180>)\n - The DTLS implementation in OpenSSL before 1.1.0 does not properly restrict the lifetime of queue entries associated with unused out-of-order messages, which allows remote attackers to cause a denial of service (memory consumption) by maintaining many crafted DTLS sessions simultaneously, related to d1_lib.c, statem_dtls.c, statem_lib.c, and statem_srvr.c. (<https://cve.circl.lu/cve/CVE-2016-2179>)\n - Integer overflow in the MDC2_Update function in crypto/mdc2/mdc2dgst.c in OpenSSL before 1.1.0 allows remote attackers to cause a denial of service (out-of-bounds write and application crash) or possibly have unspecified other impact via unknown vectors. (<https://cve.circl.lu/cve/CVE-2016-6303>)\n - The SSL and TLS components for OpenSSL 0.9.6i and earlier, 0.9.7, and 0.9.7a allow remote attackers to perform an unauthorized RSA private key operation via a modified Bleichenbacher attack that uses a large number of SSL or TLS connections using PKCS #1 v1.5 padding that cause OpenSSL to leak information regarding the relationship between ciphertext and the associated plaintext, aka the Klima-Pokorny-Rosa attack. (<https://cve.circl.lu/cve/CVE-2003-0131>)\n - crypto/x509/x509_vfy.c in OpenSSL 1.0.2i allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by triggering a CRL operation. (<https://cve.circl.lu/cve/CVE-2016-7052>)\n - statem/statem.c in OpenSSL 1.1.0a does not consider memory-block movement after a realloc call, which allows remote attackers to cause a denial of service (use-after-free) or possibly execute arbitrary code via a crafted TLS session. (<https://cve.circl.lu/cve/CVE-2016-6309>)\n - statem/statem_dtls.c in the DTLS implementation in OpenSSL 1.1.0 before 1.1.0a allocates memory before checking for an excessive length, which might allow remote attackers to cause a denial of service (memory consumption) via crafted DTLS messages. (<https://cve.circl.lu/cve/CVE-2016-6308>)\n - The state-machine implementation in OpenSSL 1.1.0 before 1.1.0a allocates memory before checking for an excessive length, which might allow remote attackers to cause a denial of service (memory consumption) via crafted TLS messages, related to statem/statem.c and statem/statem_lib.c. (<https://cve.circl.lu/cve/CVE-2016-6307>)\n - The certificate parser in OpenSSL before 1.0.1u and 1.0.2 before 1.0.2i might allow remote attackers to cause a denial of service (out-of-bounds read) via crafted certificate operations, related to s3_clnt.c and s3_srvr.c. (<https://cve.circl.lu/cve/CVE-2016-6306>)\n - The ssl3_read_bytes function in record/rec_layer_s3.c in OpenSSL 1.1.0 before 1.1.0a allows remote attackers to cause a denial of service (infinite loop) by triggering a zero-length record in an SSL_peek call. (<https://cve.circl.lu/cve/CVE-2016-6305>)\n - Multiple memory leaks in t1_lib.c in OpenSSL before 1.0.1u, 1.0.2 before 1.0.2i, and 1.1.0 before 1.1.0a allow remote attackers to cause a denial of service (memory consumption) via large OCSP Status Request extensions. (<https://cve.circl.lu/cve/CVE-2016-6304>)\n - crypto/rsa/rsa_gen.c in OpenSSL before 0.9.6 mishandles C bitwise-shift operations that exceed the size of an expression, which makes it easier for remote attackers to defeat cryptographic protection mechanisms by leveraging improper RSA key generation on 64-bit HP-UX platforms. (<https://cve.circl.lu/cve/CVE-2000-1254>)\n - Race condition in the ssl3_read_bytes function in s3_pkt.c in OpenSSL through 1.0.1g, when SSL_MODE_RELEASE_BUFFERS is enabled, allows remote attackers to inject data across sessions or cause a denial of service (use-after-free and parsing error) via an SSL connection in a multithreaded environment. (<https://cve.circl.lu/cve/CVE-2010-5298>)\n - The ssl3_send_client_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h, when an anonymous ECDH cipher suite is used, allows remote attackers to cause a denial of service (NULL pointer dereference and client crash) by triggering a NULL certificate value. (<https://cve.circl.lu/cve/CVE-2014-3470>)\n - OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly restrict processing of ChangeCipherSpec messages, which allows man-in-the-middle attackers to trigger use of a zero-length master key in certain OpenSSL-to-OpenSSL communications, and consequently hijack sessions or obtain sensitive information, via a crafted TLS handshake, aka the CCS Injection vulnerability. (<https://cve.circl.lu/cve/CVE-2014-0224>)\n - The do_ssl3_write function in s3_pkt.c in OpenSSL 1.x through 1.0.1g, when SSL_MODE_RELEASE_BUFFERS is enabled, does not properly manage a buffer pointer during certain recursive calls, which allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via vectors that trigger an alert condition. (<https://cve.circl.lu/cve/CVE-2014-0198>)\n - The Montgomery ladder implementation in OpenSSL through 1.0.0l does not ensure that certain swap operations have a constant-time behavior, which makes it easier for local users to obtain ECDSA nonces via a FLUSH+RELOAD cache side-channel attack. (<https://cve.circl.lu/cve/CVE-2014-0076>)\n - The ssl_set_client_disabled function in t1_lib.c in OpenSSL 1.0.1 before 1.0.1i allows remote SSL servers to cause a denial of service (NULL pointer dereference and client application crash) via a ServerHello message that includes an SRP ciphersuite without the required negotiation of that ciphersuite with the client. (<https://cve.circl.lu/cve/CVE-2014-5139>)\n - Multiple buffer overflows in crypto/srp/srp_lib.c in the SRP implementation in OpenSSL 1.0.1 before 1.0.1i allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via an invalid SRP (1) g, (2) A, or (3) B parameter. (<https://cve.circl.lu/cve/CVE-2014-3512>)\n - The ssl23_get_client_hello function in s23_srvr.c in OpenSSL 1.0.1 before 1.0.1i allows man-in-the-middle attackers to force the use of TLS 1.0 by triggering ClientHello message fragmentation in communication between a client and server that both support later TLS versions, related to a protocol downgrade issue. (<https://cve.circl.lu/cve/CVE-2014-3511>)\n - The ssl3_send_client_key_exchange function in s3_clnt.c in OpenSSL 0.9.8 before 0.9.8zb, 1.0.0 before 1.0.0n, and 1.0.1 before 1.0.1i allows remote DTLS servers to cause a denial of service (NULL pointer dereference and client application crash) via a crafted handshake message in conjunction with a (1) anonymous DH or (2) anonymous ECDH ciphersuite. (<https://cve.circl.lu/cve/CVE-2014-3510>)\n - Race condition in the ssl_parse_serverhello_tlsext function in t1_lib.c in OpenSSL 1.0.0 before 1.0.0n and 1.0.1 before 1.0.1i, when multithreading and session resumption are used, allows remote SSL servers to cause a denial of service (memory overwrite and client application crash) or possibly have unspecified other impact by sending Elliptic Curve (EC) Supported Point Formats Extension data. (<https://cve.circl.lu/cve/CVE-2014-3509>)\n - CVE Report ist too long...\u0000","childs":{"0":[[{"content":"- There is an overflow bug in the AVX2 Montgomery multiplication procedure used in exponentiation with 1024-bit moduli. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH1024 are considered just feasible, because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH1024 private key among multiple clients, which is no longer an option since CVE-2016-0701. This only affects processors that support the AVX2 but not ADX extensions like Intel Haswell (4th generation). Note: The impact from this issue is similar to CVE-2017-3736, CVE-2017-3732 and CVE-2015-3193. OpenSSL version 1.0.2-1.0.2m and 1.1.0-1.1.0g are affected. Fixed in OpenSSL 1.0.2n. Due to the low severity of this issue we are not issuing a new release of OpenSSL 1.1.0 at this time. The fix will be included in OpenSSL 1.1.0h when it becomes available. The fix is also available in commit e502cc86d in the OpenSSL git repository. (<https://cve.circl.lu/cve/CVE-2017-3738>)\n - OpenSSL 1.0.2 (starting from version 1.0.2b) introduced an error state mechanism. The intent was that if a fatal error occurred during a handshake then OpenSSL would move into the error state and would immediately fail if you attempted to continue the handshake. This works as designed for the explicit handshake functions (SSL_do_handshake(), SSL_accept() and SSL_connect()), however due to a bug it does not work correctly if SSL_read() or SSL_write() is called directly. In that scenario, if the handshake fails then a fatal error will be returned in the initial function call. If SSL_read()/SSL_write() is subsequently called by the application for the same SSL object then it will succeed and the data is passed without being decrypted/encrypted directly from the SSL/TLS record layer. In order to exploit this issue an application bug would have to be present that resulted in a call to SSL_read()/SSL_write() being issued after having already received a fatal error. OpenSSL version 1.0.2b-1.0.2m are affected. Fixed in OpenSSL 1.0.2n. OpenSSL 1.1.0 is not affected. (<https://cve.circl.lu/cve/CVE-2017-3737>)\n - A denial of service flaw was found in OpenSSL 0.9.8, 1.0.1, 1.0.2 through 1.0.2h, and 1.1.0 in the way the TLS/SSL protocol defined processing of ALERT packets during a connection handshake. A remote attacker could use this flaw to make a TLS/SSL server consume an excessive amount of CPU and fail to accept connections from other clients. (<https://cve.circl.lu/cve/CVE-2016-8610>)\n - There is a carry propagating bug in the x86_64 Montgomery squaring procedure in OpenSSL before 1.0.2m and 1.1.0 before 1.1.0g. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. This only affects processors that support the BMI1, BMI2 and ADX extensions like Intel Broadwell (5th generation) and later or AMD Ryzen. (<https://cve.circl.lu/cve/CVE-2017-3736>)\n - While parsing an IPAddressFamily extension in an X.509 certificate, it is possible to do a one-byte overread. This would result in an incorrect text display of the certificate. This bug has been present since 2006 and is present in all versions of OpenSSL before 1.0.2m and 1.1.0g. (<https://cve.circl.lu/cve/CVE-2017-3735>)\n - During a renegotiation handshake if the Encrypt-Then-Mac extension is negotiated where it was not in the original handshake (or vice-versa) then this can cause OpenSSL 1.1.0 before 1.1.0e to crash (dependent on ciphersuite). Both clients and servers are affected. (<https://cve.circl.lu/cve/CVE-2017-3733>)\n - The doapr_outch function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not verify that a certain memory allocation succeeds, which allows remote attackers to cause a denial of service (out-of-bounds write or memory consumption) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-0799. (<https://cve.circl.lu/cve/CVE-2016-2842>)\n - The DES and Triple DES ciphers, as used in the TLS, SSH, and IPSec protocols and other protocols and products, have a birthday bound of approximately four billion blocks, which makes it easier for remote attackers to obtain cleartext data via a birthday attack against a long-duration encrypted session, as demonstrated by an HTTPS session using Triple DES in CBC mode, aka a Sweet32 attack. (<https://cve.circl.lu/cve/CVE-2016-2183>)\n - The ASN.1 implementation in OpenSSL before 1.0.1o and 1.0.2 before 1.0.2c allows remote attackers to execute arbitrary code or cause a denial of service (buffer underflow and memory corruption) via an ANY field in crafted serialized data, aka the negative zero issue. (<https://cve.circl.lu/cve/CVE-2016-2108>)\n - The AES-NI implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h does not consider memory allocation during a certain padding check, which allows remote attackers to obtain sensitive cleartext information via a padding-oracle attack against an AES CBC session. NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2016-2107>)\n - The SSLv2 protocol, as used in OpenSSL before 1.0.1s and 1.0.2 before 1.0.2g and other products, requires a server to send a ServerVerify message before establishing that a client possesses certain plaintext RSA data, which makes it easier for remote attackers to decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, aka a DROWN attack. (<https://cve.circl.lu/cve/CVE-2016-0800>)\n - The fmtstr function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g improperly calculates string lengths, which allows remote attackers to cause a denial of service (overflow and out-of-bounds read) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-2842. (<https://cve.circl.lu/cve/CVE-2016-0799>)\n - Memory leak in the SRP_VBASE_get_by_user implementation in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory consumption) by providing an invalid username in a connection attempt, related to apps/s_server.c and crypto/srp/srp_vfy.c. (<https://cve.circl.lu/cve/CVE-2016-0798>)\n - Multiple integer overflows in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allow remote attackers to cause a denial of service (heap memory corruption or NULL pointer dereference) or possibly have unspecified other impact via a long digit string that is mishandled by the (1) BN_dec2bn or (2) BN_hex2bn function, related to crypto/bn/bn.h and crypto/bn/bn_print.c. (<https://cve.circl.lu/cve/CVE-2016-0797>)\n - Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (<https://cve.circl.lu/cve/CVE-2016-0705>)\n - An oracle protection mechanism in the get_client_master_key function in s2_srvr.c in the SSLv2 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a overwrites incorrect MASTER-KEY bytes during use of export cipher suites, which makes it easier for remote attackers to decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, a related issue to CVE-2016-0800. (<https://cve.circl.lu/cve/CVE-2016-0704>)\n - The get_client_master_key function in s2_srvr.c in the SSLv2 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a accepts a nonzero CLIENT-MASTER-KEY CLEAR-KEY-LENGTH value for an arbitrary cipher, which allows man-in-the-middle attackers to determine the MASTER-KEY value and decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, a related issue to CVE-2016-0800. (<https://cve.circl.lu/cve/CVE-2016-0703>)\n - The MOD_EXP_CTIME_COPY_FROM_PREBUF function in crypto/bn/bn_exp.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not properly consider cache-bank access times during modular exponentiation, which makes it easier for local users to discover RSA keys by running a crafted application on the same Intel Sandy Bridge CPU core as a victim and leveraging cache-bank conflicts, aka a CacheBleed attack. (<https://cve.circl.lu/cve/CVE-2016-0702>)\n - The DH_check_pub_key function in crypto/dh/dh_check.c in OpenSSL 1.0.2 before 1.0.2f does not ensure that prime numbers are appropriate for Diffie-Hellman (DH) key exchange, which makes it easier for remote attackers to discover a private DH exponent by making multiple handshakes with a peer that chose an inappropriate number, as demonstrated by a number in an X9.42 file. (<https://cve.circl.lu/cve/CVE-2016-0701>)\n - ssl/s2_srvr.c in OpenSSL 1.0.1 before 1.0.1r and 1.0.2 before 1.0.2f does not prevent use of disabled ciphers, which makes it easier for man-in-the-middle attackers to defeat cryptographic protection mechanisms by performing computations on SSLv2 traffic, related to the get_client_master_key and get_client_hello functions. (<https://cve.circl.lu/cve/CVE-2015-3197>)\n - ssl/s3_clnt.c in OpenSSL 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1p, and 1.0.2 before 1.0.2d, when used for a multi-threaded client, writes the PSK identity hint to an incorrect data structure, which allows remote servers to cause a denial of service (race condition and double free) via a crafted ServerKeyExchange message. (<https://cve.circl.lu/cve/CVE-2015-3196>)\n - The ASN1_TFLG_COMBINE implementation in crypto/asn1/tasn_dec.c in OpenSSL before 0.9.8zh, 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1q, and 1.0.2 before 1.0.2e mishandles errors caused by malformed X509_ATTRIBUTE data, which allows remote attackers to obtain sensitive information from process memory by triggering a decoding failure in a PKCS#7 or CMS application. (<https://cve.circl.lu/cve/CVE-2015-3195>)\n - crypto/rsa/rsa_ameth.c in OpenSSL 1.0.1 before 1.0.1q and 1.0.2 before 1.0.2e allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an RSA PSS ASN.1 signature that lacks a mask generation function parameter. (<https://cve.circl.lu/cve/CVE-2015-3194>)\n - The Montgomery squaring implementation in crypto/bn/asm/x86_64-mont5.pl in OpenSSL 1.0.2 before 1.0.2e on the x86_64 platform, as used by the BN_mod_exp function, mishandles carry propagation and produces incorrect output, which makes it easier for remote attackers to obtain sensitive private-key information via an attack against use of a (1) Diffie-Hellman (DH) or (2) Diffie-Hellman Ephemeral (DHE) ciphersuite. (<https://cve.circl.lu/cve/CVE-2015-3193>)\n - The ssl3_get_key_exchange function in ssl/s3_clnt.c in OpenSSL 1.0.2 before 1.0.2e allows remote servers to cause a denial of service (segmentation fault) via a zero p value in an anonymous Diffie-Hellman (DH) ServerKeyExchange message. (<https://cve.circl.lu/cve/CVE-2015-1794>)\n - There is a carry propagating bug in the x86_64 Montgomery squaring procedure in OpenSSL 1.0.2 before 1.0.2k and 1.1.0 before 1.1.0d. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. For example this can occur by default in OpenSSL DHE based SSL/TLS ciphersuites. Note: This issue is very similar to CVE-2015-3193 but must be treated as a separate problem. (<https://cve.circl.lu/cve/CVE-2017-3732>)\n - If an SSL/TLS server or client is running on a 32-bit host, and a specific cipher is being used, then a truncated packet can cause that server or client to perform an out-of-bounds read, usually resulting in a crash. For OpenSSL 1.1.0, the crash can be triggered when using CHACHA20/POLY1305; users should upgrade to 1.1.0d. For Openssl 1.0.2, the crash can be triggered when using RC4-MD5; users who have not disabled that algorithm should update to 1.0.2k. (<https://cve.circl.lu/cve/CVE-2017-3731>)\n - In OpenSSL 1.1.0 before 1.1.0d, if a malicious server supplies bad parameters for a DHE or ECDHE key exchange then this can result in the client attempting to dereference a NULL pointer leading to a client crash. This could be exploited in a Denial of Service attack. (<https://cve.circl.lu/cve/CVE-2017-3730>)\n - There is a carry propagating bug in the Broadwell-specific Montgomery multiplication procedure in OpenSSL 1.0.2 and 1.1.0 before 1.1.0c that handles input lengths divisible by, but longer than 256 bits. Analysis suggests that attacks against RSA, DSA and DH private keys are impossible. This is because the subroutine in question is not used in operations with the private key itself and an input of the attacker's direct choice. Otherwise the bug can manifest itself as transient authentication and key negotiation failures or reproducible erroneous outcome of public-key operations with specially crafted input. Among EC algorithms only Brainpool P-512 curves are affected and one presumably can attack ECDH key negotiation. Impact was not analyzed in detail, because pre-requisites for attack are considered unlikely. Namely multiple clients have to choose the curve in question and the server has to share the private key among them, neither of which is default behaviour. Even then only clients that chose the curve will be affected. (<https://cve.circl.lu/cve/CVE-2016-7055>)\n - In OpenSSL 1.1.0 before 1.1.0c, TLS connections using *-CHACHA20-POLY1305 ciphersuites are susceptible to a DoS attack by corrupting larger payloads. This can result in an OpenSSL crash. This issue is not considered to be exploitable beyond a DoS. (<https://cve.circl.lu/cve/CVE-2016-7054>)\n - In OpenSSL 1.1.0 before 1.1.0c, applications parsing invalid CMS structures can crash with a NULL pointer dereference. This is caused by a bug in the handling of the ASN.1 CHOICE type in OpenSSL 1.1.0 which can result in a NULL value being passed to the structure callback if an attempt is made to free certain invalid encodings. Only CHOICE structures using a callback which do not handle NULL value are affected. (<https://cve.circl.lu/cve/CVE-2016-7053>)\n - The SSL protocol 3.0, as used in OpenSSL through 1.0.1i and other products, uses nondeterministic CBC padding, which makes it easier for man-in-the-middle attackers to obtain cleartext data via a padding-oracle attack, aka the POODLE issue. (<https://cve.circl.lu/cve/CVE-2014-3566>)\n - The BN_bn2dec function in crypto/bn/bn_print.c in OpenSSL before 1.1.0 does not properly validate division results, which allows remote attackers to cause a denial of service (out-of-bounds write and application crash) or possibly have unspecified other impact via unknown vectors. (<https://cve.circl.lu/cve/CVE-2016-2182>)\n - The X509_NAME_oneline function in crypto/x509/x509_obj.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to obtain sensitive information from process stack memory or cause a denial of service (buffer over-read) via crafted EBCDIC ASN.1 data. (<https://cve.circl.lu/cve/CVE-2016-2176>)\n - The asn1_d2i_read_bio function in crypto/asn1/a_d2i_fp.c in the ASN.1 BIO implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (memory consumption) via a short invalid encoding. (<https://cve.circl.lu/cve/CVE-2016-2109>)\n - Integer overflow in the EVP_EncryptUpdate function in crypto/evp/evp_enc.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of data. (<https://cve.circl.lu/cve/CVE-2016-2106>)\n - Integer overflow in the EVP_EncodeUpdate function in crypto/evp/encode.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of binary data. (<https://cve.circl.lu/cve/CVE-2016-2105>)\n - The dsa_sign_setup function in crypto/dsa/dsa_ossl.c in OpenSSL through 1.0.2h does not properly ensure the use of constant-time operations, which makes it easier for local users to discover a DSA private key via a timing side-channel attack. (<https://cve.circl.lu/cve/CVE-2016-2178>)\n - OpenSSL through 1.0.2h incorrectly uses pointer arithmetic for heap-buffer boundary checks, which might allow remote attackers to cause a denial of service (integer overflow and application crash) or possibly have unspecified other impact by leveraging unexpected malloc behavior, related to s3_srvr.c, ssl_sess.c, and t1_lib.c. (<https://cve.circl.lu/cve/CVE-2016-2177>)\n - The tls_decrypt_ticket function in ssl/t1_lib.c in OpenSSL before 1.1.0 does not consider the HMAC size during validation of the ticket length, which allows remote attackers to cause a denial of service via a ticket that is too short. (<https://cve.circl.lu/cve/CVE-2016-6302>)\n - The Anti-Replay feature in the DTLS implementation in OpenSSL before 1.1.0 mishandles early use of a new epoch number in conjunction with a large sequence number, which allows remote attackers to cause a denial of service (false-positive packet drops) via spoofed DTLS records, related to rec_layer_d1.c and ssl3_record.c. (<https://cve.circl.lu/cve/CVE-2016-2181>)\n - The TS_OBJ_print_bio function in crypto/ts/ts_lib.c in the X.509 Public Key Infrastructure Time-Stamp Protocol (TSP) implementation in OpenSSL through 1.0.2h allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted time-stamp file that is mishandled by the openssl ts command. (<https://cve.circl.lu/cve/CVE-2016-2180>)\n - The DTLS implementation in OpenSSL before 1.1.0 does not properly restrict the lifetime of queue entries associated with unused out-of-order messages, which allows remote attackers to cause a denial of service (memory consumption) by maintaining many crafted DTLS sessions simultaneously, related to d1_lib.c, statem_dtls.c, statem_lib.c, and statem_srvr.c. (<https://cve.circl.lu/cve/CVE-2016-2179>)\n - Integer overflow in the MDC2_Update function in crypto/mdc2/mdc2dgst.c in OpenSSL before 1.1.0 allows remote attackers to cause a denial of service (out-of-bounds write and application crash) or possibly have unspecified other impact via unknown vectors. (<https://cve.circl.lu/cve/CVE-2016-6303>)\n - The SSL and TLS components for OpenSSL 0.9.6i and earlier, 0.9.7, and 0.9.7a allow remote attackers to perform an unauthorized RSA private key operation via a modified Bleichenbacher attack that uses a large number of SSL or TLS connections using PKCS #1 v1.5 padding that cause OpenSSL to leak information regarding the relationship between ciphertext and the associated plaintext, aka the Klima-Pokorny-Rosa attack. (<https://cve.circl.lu/cve/CVE-2003-0131>)\n - crypto/x509/x509_vfy.c in OpenSSL 1.0.2i allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by triggering a CRL operation. (<https://cve.circl.lu/cve/CVE-2016-7052>)\n - statem/statem.c in OpenSSL 1.1.0a does not consider memory-block movement after a realloc call, which allows remote attackers to cause a denial of service (use-after-free) or possibly execute arbitrary code via a crafted TLS session. (<https://cve.circl.lu/cve/CVE-2016-6309>)\n - statem/statem_dtls.c in the DTLS implementation in OpenSSL 1.1.0 before 1.1.0a allocates memory before checking for an excessive length, which might allow remote attackers to cause a denial of service (memory consumption) via crafted DTLS messages. (<https://cve.circl.lu/cve/CVE-2016-6308>)\n - The state-machine implementation in OpenSSL 1.1.0 before 1.1.0a allocates memory before checking for an excessive length, which might allow remote attackers to cause a denial of service (memory consumption) via crafted TLS messages, related to statem/statem.c and statem/statem_lib.c. (<https://cve.circl.lu/cve/CVE-2016-6307>)\n - The certificate parser in OpenSSL before 1.0.1u and 1.0.2 before 1.0.2i might allow remote attackers to cause a denial of service (out-of-bounds read) via crafted certificate operations, related to s3_clnt.c and s3_srvr.c. (<https://cve.circl.lu/cve/CVE-2016-6306>)\n - The ssl3_read_bytes function in record/rec_layer_s3.c in OpenSSL 1.1.0 before 1.1.0a allows remote attackers to cause a denial of service (infinite loop) by triggering a zero-length record in an SSL_peek call. (<https://cve.circl.lu/cve/CVE-2016-6305>)\n - Multiple memory leaks in t1_lib.c in OpenSSL before 1.0.1u, 1.0.2 before 1.0.2i, and 1.1.0 before 1.1.0a allow remote attackers to cause a denial of service (memory consumption) via large OCSP Status Request extensions. (<https://cve.circl.lu/cve/CVE-2016-6304>)\n - crypto/rsa/rsa_gen.c in OpenSSL before 0.9.6 mishandles C bitwise-shift operations that exceed the size of an expression, which makes it easier for remote attackers to defeat cryptographic protection mechanisms by leveraging improper RSA key generation on 64-bit HP-UX platforms. (<https://cve.circl.lu/cve/CVE-2000-1254>)\n - Race condition in the ssl3_read_bytes function in s3_pkt.c in OpenSSL through 1.0.1g, when SSL_MODE_RELEASE_BUFFERS is enabled, allows remote attackers to inject data across sessions or cause a denial of service (use-after-free and parsing error) via an SSL connection in a multithreaded environment. (<https://cve.circl.lu/cve/CVE-2010-5298>)\n - The ssl3_send_client_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h, when an anonymous ECDH cipher suite is used, allows remote attackers to cause a denial of service (NULL pointer dereference and client crash) by triggering a NULL certificate value. (<https://cve.circl.lu/cve/CVE-2014-3470>)\n - OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly restrict processing of ChangeCipherSpec messages, which allows man-in-the-middle attackers to trigger use of a zero-length master key in certain OpenSSL-to-OpenSSL communications, and consequently hijack sessions or obtain sensitive information, via a crafted TLS handshake, aka the CCS Injection vulnerability. (<https://cve.circl.lu/cve/CVE-2014-0224>)\n - The do_ssl3_write function in s3_pkt.c in OpenSSL 1.x through 1.0.1g, when SSL_MODE_RELEASE_BUFFERS is enabled, does not properly manage a buffer pointer during certain recursive calls, which allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via vectors that trigger an alert condition. (<https://cve.circl.lu/cve/CVE-2014-0198>)\n - The Montgomery ladder implementation in OpenSSL through 1.0.0l does not ensure that certain swap operations have a constant-time behavior, which makes it easier for local users to obtain ECDSA nonces via a FLUSH+RELOAD cache side-channel attack. (<https://cve.circl.lu/cve/CVE-2014-0076>)\n - The ssl_set_client_disabled function in t1_lib.c in OpenSSL 1.0.1 before 1.0.1i allows remote SSL servers to cause a denial of service (NULL pointer dereference and client application crash) via a ServerHello message that includes an SRP ciphersuite without the required negotiation of that ciphersuite with the client. (<https://cve.circl.lu/cve/CVE-2014-5139>)\n - Multiple buffer overflows in crypto/srp/srp_lib.c in the SRP implementation in OpenSSL 1.0.1 before 1.0.1i allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via an invalid SRP (1) g, (2) A, or (3) B parameter. (<https://cve.circl.lu/cve/CVE-2014-3512>)\n - The ssl23_get_client_hello function in s23_srvr.c in OpenSSL 1.0.1 before 1.0.1i allows man-in-the-middle attackers to force the use of TLS 1.0 by triggering ClientHello message fragmentation in communication between a client and server that both support later TLS versions, related to a protocol downgrade issue. (<https://cve.circl.lu/cve/CVE-2014-3511>)\n - The ssl3_send_client_key_exchange function in s3_clnt.c in OpenSSL 0.9.8 before 0.9.8zb, 1.0.0 before 1.0.0n, and 1.0.1 before 1.0.1i allows remote DTLS servers to cause a denial of service (NULL pointer dereference and client application crash) via a crafted handshake message in conjunction with a (1) anonymous DH or (2) anonymous ECDH ciphersuite. (<https://cve.circl.lu/cve/CVE-2014-3510>)\n - Race condition in the ssl_parse_serverhello_tlsext function in t1_lib.c in OpenSSL 1.0.0 before 1.0.0n and 1.0.1 before 1.0.1i, when multithreading and session resumption are used, allows remote SSL servers to cause a denial of service (memory overwrite and client application crash) or possibly have unspecified other impact by sending Elliptic Curve (EC) Supported Point Formats Extension data. (<https://cve.circl.lu/cve/CVE-2014-3509>)\n - CVE Report ist too long...","plain":"- There is an overflow bug in the AVX2 Montgomery multiplication procedure used in exponentiation with 1024-bit moduli. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH1024 are considered just feasible, because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH1024 private key among multiple clients, which is no longer an option since CVE-2016-0701. This only affects processors that support the AVX2 but not ADX extensions like Intel Haswell (4th generation). Note: The impact from this issue is similar to CVE-2017-3736, CVE-2017-3732 and CVE-2015-3193. OpenSSL version 1.0.2-1.0.2m and 1.1.0-1.1.0g are affected. Fixed in OpenSSL 1.0.2n. Due to the low severity of this issue we are not issuing a new release of OpenSSL 1.1.0 at this time. The fix will be included in OpenSSL 1.1.0h when it becomes available. The fix is also available in commit e502cc86d in the OpenSSL git repository. (<https://cve.circl.lu/cve/CVE-2017-3738>)\n - OpenSSL 1.0.2 (starting from version 1.0.2b) introduced an error state mechanism. The intent was that if a fatal error occurred during a handshake then OpenSSL would move into the error state and would immediately fail if you attempted to continue the handshake. This works as designed for the explicit handshake functions (SSL_do_handshake(), SSL_accept() and SSL_connect()), however due to a bug it does not work correctly if SSL_read() or SSL_write() is called directly. In that scenario, if the handshake fails then a fatal error will be returned in the initial function call. If SSL_read()/SSL_write() is subsequently called by the application for the same SSL object then it will succeed and the data is passed without being decrypted/encrypted directly from the SSL/TLS record layer. In order to exploit this issue an application bug would have to be present that resulted in a call to SSL_read()/SSL_write() being issued after having already received a fatal error. OpenSSL version 1.0.2b-1.0.2m are affected. Fixed in OpenSSL 1.0.2n. OpenSSL 1.1.0 is not affected. (<https://cve.circl.lu/cve/CVE-2017-3737>)\n - A denial of service flaw was found in OpenSSL 0.9.8, 1.0.1, 1.0.2 through 1.0.2h, and 1.1.0 in the way the TLS/SSL protocol defined processing of ALERT packets during a connection handshake. A remote attacker could use this flaw to make a TLS/SSL server consume an excessive amount of CPU and fail to accept connections from other clients. (<https://cve.circl.lu/cve/CVE-2016-8610>)\n - There is a carry propagating bug in the x86_64 Montgomery squaring procedure in OpenSSL before 1.0.2m and 1.1.0 before 1.1.0g. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. This only affects processors that support the BMI1, BMI2 and ADX extensions like Intel Broadwell (5th generation) and later or AMD Ryzen. (<https://cve.circl.lu/cve/CVE-2017-3736>)\n - While parsing an IPAddressFamily extension in an X.509 certificate, it is possible to do a one-byte overread. This would result in an incorrect text display of the certificate. This bug has been present since 2006 and is present in all versions of OpenSSL before 1.0.2m and 1.1.0g. (<https://cve.circl.lu/cve/CVE-2017-3735>)\n - During a renegotiation handshake if the Encrypt-Then-Mac extension is negotiated where it was not in the original handshake (or vice-versa) then this can cause OpenSSL 1.1.0 before 1.1.0e to crash (dependent on ciphersuite). Both clients and servers are affected. (<https://cve.circl.lu/cve/CVE-2017-3733>)\n - The doapr_outch function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not verify that a certain memory allocation succeeds, which allows remote attackers to cause a denial of service (out-of-bounds write or memory consumption) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-0799. (<https://cve.circl.lu/cve/CVE-2016-2842>)\n - The DES and Triple DES ciphers, as used in the TLS, SSH, and IPSec protocols and other protocols and products, have a birthday bound of approximately four billion blocks, which makes it easier for remote attackers to obtain cleartext data via a birthday attack against a long-duration encrypted session, as demonstrated by an HTTPS session using Triple DES in CBC mode, aka a Sweet32 attack. (<https://cve.circl.lu/cve/CVE-2016-2183>)\n - The ASN.1 implementation in OpenSSL before 1.0.1o and 1.0.2 before 1.0.2c allows remote attackers to execute arbitrary code or cause a denial of service (buffer underflow and memory corruption) via an ANY field in crafted serialized data, aka the negative zero issue. (<https://cve.circl.lu/cve/CVE-2016-2108>)\n - The AES-NI implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h does not consider memory allocation during a certain padding check, which allows remote attackers to obtain sensitive cleartext information via a padding-oracle attack against an AES CBC session. NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2016-2107>)\n - The SSLv2 protocol, as used in OpenSSL before 1.0.1s and 1.0.2 before 1.0.2g and other products, requires a server to send a ServerVerify message before establishing that a client possesses certain plaintext RSA data, which makes it easier for remote attackers to decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, aka a DROWN attack. (<https://cve.circl.lu/cve/CVE-2016-0800>)\n - The fmtstr function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g improperly calculates string lengths, which allows remote attackers to cause a denial of service (overflow and out-of-bounds read) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-2842. (<https://cve.circl.lu/cve/CVE-2016-0799>)\n - Memory leak in the SRP_VBASE_get_by_user implementation in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory consumption) by providing an invalid username in a connection attempt, related to apps/s_server.c and crypto/srp/srp_vfy.c. (<https://cve.circl.lu/cve/CVE-2016-0798>)\n - Multiple integer overflows in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allow remote attackers to cause a denial of service (heap memory corruption or NULL pointer dereference) or possibly have unspecified other impact via a long digit string that is mishandled by the (1) BN_dec2bn or (2) BN_hex2bn function, related to crypto/bn/bn.h and crypto/bn/bn_print.c. (<https://cve.circl.lu/cve/CVE-2016-0797>)\n - Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (<https://cve.circl.lu/cve/CVE-2016-0705>)\n - An oracle protection mechanism in the get_client_master_key function in s2_srvr.c in the SSLv2 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a overwrites incorrect MASTER-KEY bytes during use of export cipher suites, which makes it easier for remote attackers to decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, a related issue to CVE-2016-0800. (<https://cve.circl.lu/cve/CVE-2016-0704>)\n - The get_client_master_key function in s2_srvr.c in the SSLv2 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a accepts a nonzero CLIENT-MASTER-KEY CLEAR-KEY-LENGTH value for an arbitrary cipher, which allows man-in-the-middle attackers to determine the MASTER-KEY value and decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, a related issue to CVE-2016-0800. (<https://cve.circl.lu/cve/CVE-2016-0703>)\n - The MOD_EXP_CTIME_COPY_FROM_PREBUF function in crypto/bn/bn_exp.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not properly consider cache-bank access times during modular exponentiation, which makes it easier for local users to discover RSA keys by running a crafted application on the same Intel Sandy Bridge CPU core as a victim and leveraging cache-bank conflicts, aka a CacheBleed attack. (<https://cve.circl.lu/cve/CVE-2016-0702>)\n - The DH_check_pub_key function in crypto/dh/dh_check.c in OpenSSL 1.0.2 before 1.0.2f does not ensure that prime numbers are appropriate for Diffie-Hellman (DH) key exchange, which makes it easier for remote attackers to discover a private DH exponent by making multiple handshakes with a peer that chose an inappropriate number, as demonstrated by a number in an X9.42 file. (<https://cve.circl.lu/cve/CVE-2016-0701>)\n - ssl/s2_srvr.c in OpenSSL 1.0.1 before 1.0.1r and 1.0.2 before 1.0.2f does not prevent use of disabled ciphers, which makes it easier for man-in-the-middle attackers to defeat cryptographic protection mechanisms by performing computations on SSLv2 traffic, related to the get_client_master_key and get_client_hello functions. (<https://cve.circl.lu/cve/CVE-2015-3197>)\n - ssl/s3_clnt.c in OpenSSL 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1p, and 1.0.2 before 1.0.2d, when used for a multi-threaded client, writes the PSK identity hint to an incorrect data structure, which allows remote servers to cause a denial of service (race condition and double free) via a crafted ServerKeyExchange message. (<https://cve.circl.lu/cve/CVE-2015-3196>)\n - The ASN1_TFLG_COMBINE implementation in crypto/asn1/tasn_dec.c in OpenSSL before 0.9.8zh, 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1q, and 1.0.2 before 1.0.2e mishandles errors caused by malformed X509_ATTRIBUTE data, which allows remote attackers to obtain sensitive information from process memory by triggering a decoding failure in a PKCS#7 or CMS application. (<https://cve.circl.lu/cve/CVE-2015-3195>)\n - crypto/rsa/rsa_ameth.c in OpenSSL 1.0.1 before 1.0.1q and 1.0.2 before 1.0.2e allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an RSA PSS ASN.1 signature that lacks a mask generation function parameter. (<https://cve.circl.lu/cve/CVE-2015-3194>)\n - The Montgomery squaring implementation in crypto/bn/asm/x86_64-mont5.pl in OpenSSL 1.0.2 before 1.0.2e on the x86_64 platform, as used by the BN_mod_exp function, mishandles carry propagation and produces incorrect output, which makes it easier for remote attackers to obtain sensitive private-key information via an attack against use of a (1) Diffie-Hellman (DH) or (2) Diffie-Hellman Ephemeral (DHE) ciphersuite. (<https://cve.circl.lu/cve/CVE-2015-3193>)\n - The ssl3_get_key_exchange function in ssl/s3_clnt.c in OpenSSL 1.0.2 before 1.0.2e allows remote servers to cause a denial of service (segmentation fault) via a zero p value in an anonymous Diffie-Hellman (DH) ServerKeyExchange message. (<https://cve.circl.lu/cve/CVE-2015-1794>)\n - There is a carry propagating bug in the x86_64 Montgomery squaring procedure in OpenSSL 1.0.2 before 1.0.2k and 1.1.0 before 1.1.0d. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. For example this can occur by default in OpenSSL DHE based SSL/TLS ciphersuites. Note: This issue is very similar to CVE-2015-3193 but must be treated as a separate problem. (<https://cve.circl.lu/cve/CVE-2017-3732>)\n - If an SSL/TLS server or client is running on a 32-bit host, and a specific cipher is being used, then a truncated packet can cause that server or client to perform an out-of-bounds read, usually resulting in a crash. For OpenSSL 1.1.0, the crash can be triggered when using CHACHA20/POLY1305; users should upgrade to 1.1.0d. For Openssl 1.0.2, the crash can be triggered when using RC4-MD5; users who have not disabled that algorithm should update to 1.0.2k. (<https://cve.circl.lu/cve/CVE-2017-3731>)\n - In OpenSSL 1.1.0 before 1.1.0d, if a malicious server supplies bad parameters for a DHE or ECDHE key exchange then this can result in the client attempting to dereference a NULL pointer leading to a client crash. This could be exploited in a Denial of Service attack. (<https://cve.circl.lu/cve/CVE-2017-3730>)\n - There is a carry propagating bug in the Broadwell-specific Montgomery multiplication procedure in OpenSSL 1.0.2 and 1.1.0 before 1.1.0c that handles input lengths divisible by, but longer than 256 bits. Analysis suggests that attacks against RSA, DSA and DH private keys are impossible. This is because the subroutine in question is not used in operations with the private key itself and an input of the attacker's direct choice. Otherwise the bug can manifest itself as transient authentication and key negotiation failures or reproducible erroneous outcome of public-key operations with specially crafted input. Among EC algorithms only Brainpool P-512 curves are affected and one presumably can attack ECDH key negotiation. Impact was not analyzed in detail, because pre-requisites for attack are considered unlikely. Namely multiple clients have to choose the curve in question and the server has to share the private key among them, neither of which is default behaviour. Even then only clients that chose the curve will be affected. (<https://cve.circl.lu/cve/CVE-2016-7055>)\n - In OpenSSL 1.1.0 before 1.1.0c, TLS connections using *-CHACHA20-POLY1305 ciphersuites are susceptible to a DoS attack by corrupting larger payloads. This can result in an OpenSSL crash. This issue is not considered to be exploitable beyond a DoS. (<https://cve.circl.lu/cve/CVE-2016-7054>)\n - In OpenSSL 1.1.0 before 1.1.0c, applications parsing invalid CMS structures can crash with a NULL pointer dereference. This is caused by a bug in the handling of the ASN.1 CHOICE type in OpenSSL 1.1.0 which can result in a NULL value being passed to the structure callback if an attempt is made to free certain invalid encodings. Only CHOICE structures using a callback which do not handle NULL value are affected. (<https://cve.circl.lu/cve/CVE-2016-7053>)\n - The SSL protocol 3.0, as used in OpenSSL through 1.0.1i and other products, uses nondeterministic CBC padding, which makes it easier for man-in-the-middle attackers to obtain cleartext data via a padding-oracle attack, aka the POODLE issue. (<https://cve.circl.lu/cve/CVE-2014-3566>)\n - The BN_bn2dec function in crypto/bn/bn_print.c in OpenSSL before 1.1.0 does not properly validate division results, which allows remote attackers to cause a denial of service (out-of-bounds write and application crash) or possibly have unspecified other impact via unknown vectors. (<https://cve.circl.lu/cve/CVE-2016-2182>)\n - The X509_NAME_oneline function in crypto/x509/x509_obj.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to obtain sensitive information from process stack memory or cause a denial of service (buffer over-read) via crafted EBCDIC ASN.1 data. (<https://cve.circl.lu/cve/CVE-2016-2176>)\n - The asn1_d2i_read_bio function in crypto/asn1/a_d2i_fp.c in the ASN.1 BIO implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (memory consumption) via a short invalid encoding. (<https://cve.circl.lu/cve/CVE-2016-2109>)\n - Integer overflow in the EVP_EncryptUpdate function in crypto/evp/evp_enc.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of data. (<https://cve.circl.lu/cve/CVE-2016-2106>)\n - Integer overflow in the EVP_EncodeUpdate function in crypto/evp/encode.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of binary data. (<https://cve.circl.lu/cve/CVE-2016-2105>)\n - The dsa_sign_setup function in crypto/dsa/dsa_ossl.c in OpenSSL through 1.0.2h does not properly ensure the use of constant-time operations, which makes it easier for local users to discover a DSA private key via a timing side-channel attack. (<https://cve.circl.lu/cve/CVE-2016-2178>)\n - OpenSSL through 1.0.2h incorrectly uses pointer arithmetic for heap-buffer boundary checks, which might allow remote attackers to cause a denial of service (integer overflow and application crash) or possibly have unspecified other impact by leveraging unexpected malloc behavior, related to s3_srvr.c, ssl_sess.c, and t1_lib.c. (<https://cve.circl.lu/cve/CVE-2016-2177>)\n - The tls_decrypt_ticket function in ssl/t1_lib.c in OpenSSL before 1.1.0 does not consider the HMAC size during validation of the ticket length, which allows remote attackers to cause a denial of service via a ticket that is too short. (<https://cve.circl.lu/cve/CVE-2016-6302>)\n - The Anti-Replay feature in the DTLS implementation in OpenSSL before 1.1.0 mishandles early use of a new epoch number in conjunction with a large sequence number, which allows remote attackers to cause a denial of service (false-positive packet drops) via spoofed DTLS records, related to rec_layer_d1.c and ssl3_record.c. (<https://cve.circl.lu/cve/CVE-2016-2181>)\n - The TS_OBJ_print_bio function in crypto/ts/ts_lib.c in the X.509 Public Key Infrastructure Time-Stamp Protocol (TSP) implementation in OpenSSL through 1.0.2h allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted time-stamp file that is mishandled by the openssl ts command. (<https://cve.circl.lu/cve/CVE-2016-2180>)\n - The DTLS implementation in OpenSSL before 1.1.0 does not properly restrict the lifetime of queue entries associated with unused out-of-order messages, which allows remote attackers to cause a denial of service (memory consumption) by maintaining many crafted DTLS sessions simultaneously, related to d1_lib.c, statem_dtls.c, statem_lib.c, and statem_srvr.c. (<https://cve.circl.lu/cve/CVE-2016-2179>)\n - Integer overflow in the MDC2_Update function in crypto/mdc2/mdc2dgst.c in OpenSSL before 1.1.0 allows remote attackers to cause a denial of service (out-of-bounds write and application crash) or possibly have unspecified other impact via unknown vectors. (<https://cve.circl.lu/cve/CVE-2016-6303>)\n - The SSL and TLS components for OpenSSL 0.9.6i and earlier, 0.9.7, and 0.9.7a allow remote attackers to perform an unauthorized RSA private key operation via a modified Bleichenbacher attack that uses a large number of SSL or TLS connections using PKCS #1 v1.5 padding that cause OpenSSL to leak information regarding the relationship between ciphertext and the associated plaintext, aka the Klima-Pokorny-Rosa attack. (<https://cve.circl.lu/cve/CVE-2003-0131>)\n - crypto/x509/x509_vfy.c in OpenSSL 1.0.2i allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by triggering a CRL operation. (<https://cve.circl.lu/cve/CVE-2016-7052>)\n - statem/statem.c in OpenSSL 1.1.0a does not consider memory-block movement after a realloc call, which allows remote attackers to cause a denial of service (use-after-free) or possibly execute arbitrary code via a crafted TLS session. (<https://cve.circl.lu/cve/CVE-2016-6309>)\n - statem/statem_dtls.c in the DTLS implementation in OpenSSL 1.1.0 before 1.1.0a allocates memory before checking for an excessive length, which might allow remote attackers to cause a denial of service (memory consumption) via crafted DTLS messages. (<https://cve.circl.lu/cve/CVE-2016-6308>)\n - The state-machine implementation in OpenSSL 1.1.0 before 1.1.0a allocates memory before checking for an excessive length, which might allow remote attackers to cause a denial of service (memory consumption) via crafted TLS messages, related to statem/statem.c and statem/statem_lib.c. (<https://cve.circl.lu/cve/CVE-2016-6307>)\n - The certificate parser in OpenSSL before 1.0.1u and 1.0.2 before 1.0.2i might allow remote attackers to cause a denial of service (out-of-bounds read) via crafted certificate operations, related to s3_clnt.c and s3_srvr.c. (<https://cve.circl.lu/cve/CVE-2016-6306>)\n - The ssl3_read_bytes function in record/rec_layer_s3.c in OpenSSL 1.1.0 before 1.1.0a allows remote attackers to cause a denial of service (infinite loop) by triggering a zero-length record in an SSL_peek call. (<https://cve.circl.lu/cve/CVE-2016-6305>)\n - Multiple memory leaks in t1_lib.c in OpenSSL before 1.0.1u, 1.0.2 before 1.0.2i, and 1.1.0 before 1.1.0a allow remote attackers to cause a denial of service (memory consumption) via large OCSP Status Request extensions. (<https://cve.circl.lu/cve/CVE-2016-6304>)\n - crypto/rsa/rsa_gen.c in OpenSSL before 0.9.6 mishandles C bitwise-shift operations that exceed the size of an expression, which makes it easier for remote attackers to defeat cryptographic protection mechanisms by leveraging improper RSA key generation on 64-bit HP-UX platforms. (<https://cve.circl.lu/cve/CVE-2000-1254>)\n - Race condition in the ssl3_read_bytes function in s3_pkt.c in OpenSSL through 1.0.1g, when SSL_MODE_RELEASE_BUFFERS is enabled, allows remote attackers to inject data across sessions or cause a denial of service (use-after-free and parsing error) via an SSL connection in a multithreaded environment. (<https://cve.circl.lu/cve/CVE-2010-5298>)\n - The ssl3_send_client_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h, when an anonymous ECDH cipher suite is used, allows remote attackers to cause a denial of service (NULL pointer dereference and client crash) by triggering a NULL certificate value. (<https://cve.circl.lu/cve/CVE-2014-3470>)\n - OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly restrict processing of ChangeCipherSpec messages, which allows man-in-the-middle attackers to trigger use of a zero-length master key in certain OpenSSL-to-OpenSSL communications, and consequently hijack sessions or obtain sensitive information, via a crafted TLS handshake, aka the CCS Injection vulnerability. (<https://cve.circl.lu/cve/CVE-2014-0224>)\n - The do_ssl3_write function in s3_pkt.c in OpenSSL 1.x through 1.0.1g, when SSL_MODE_RELEASE_BUFFERS is enabled, does not properly manage a buffer pointer during certain recursive calls, which allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via vectors that trigger an alert condition. (<https://cve.circl.lu/cve/CVE-2014-0198>)\n - The Montgomery ladder implementation in OpenSSL through 1.0.0l does not ensure that certain swap operations have a constant-time behavior, which makes it easier for local users to obtain ECDSA nonces via a FLUSH+RELOAD cache side-channel attack. (<https://cve.circl.lu/cve/CVE-2014-0076>)\n - The ssl_set_client_disabled function in t1_lib.c in OpenSSL 1.0.1 before 1.0.1i allows remote SSL servers to cause a denial of service (NULL pointer dereference and client application crash) via a ServerHello message that includes an SRP ciphersuite without the required negotiation of that ciphersuite with the client. (<https://cve.circl.lu/cve/CVE-2014-5139>)\n - Multiple buffer overflows in crypto/srp/srp_lib.c in the SRP implementation in OpenSSL 1.0.1 before 1.0.1i allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via an invalid SRP (1) g, (2) A, or (3) B parameter. (<https://cve.circl.lu/cve/CVE-2014-3512>)\n - The ssl23_get_client_hello function in s23_srvr.c in OpenSSL 1.0.1 before 1.0.1i allows man-in-the-middle attackers to force the use of TLS 1.0 by triggering ClientHello message fragmentation in communication between a client and server that both support later TLS versions, related to a protocol downgrade issue. (<https://cve.circl.lu/cve/CVE-2014-3511>)\n - The ssl3_send_client_key_exchange function in s3_clnt.c in OpenSSL 0.9.8 before 0.9.8zb, 1.0.0 before 1.0.0n, and 1.0.1 before 1.0.1i allows remote DTLS servers to cause a denial of service (NULL pointer dereference and client application crash) via a crafted handshake message in conjunction with a (1) anonymous DH or (2) anonymous ECDH ciphersuite. (<https://cve.circl.lu/cve/CVE-2014-3510>)\n - Race condition in the ssl_parse_serverhello_tlsext function in t1_lib.c in OpenSSL 1.0.0 before 1.0.0n and 1.0.1 before 1.0.1i, when multithreading and session resumption are used, allows remote SSL servers to cause a denial of service (memory overwrite and client application crash) or possibly have unspecified other impact by sending Elliptic Curve (EC) Supported Point Formats Extension data. (<https://cve.circl.lu/cve/CVE-2014-3509>)\n - CVE Report ist too long...\u0000","plainChilds":"","childs":[]}]]}}}]